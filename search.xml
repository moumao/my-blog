<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[关于Promise]]></title>
      <url>http://yoursite.com/2017/03/28/%E5%85%B3%E4%BA%8EPromise/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>首先设想一个日常开发常常会遇到的需求：在多个接口异步请求数据，然后利用这些数据来进行一系列的操作。一般会这样去写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">url: &apos;......&apos;,</div><div class="line">success: function (data) &#123;</div><div class="line">$.ajax(&#123;</div><div class="line">// 要在第一个请求成功后才可以执行下一步</div><div class="line">url: &apos;......&apos;,</div><div class="line">success: function (data) &#123;</div><div class="line">// ......</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125; &#125;);</div></pre></td></tr></table></figure>
<p>这样的写法的原理是，当执行一些异步操作时，我们需要知道操作是否已经完成，所有当执行完成的时候会返回一个回调函数，表示操作已经完成。</p>
<p>使用回调函数的形式理解起来并不困难，但是实际的应用当中会有以下的缺点：</p>
<blockquote>
<p>1.在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的 Callback Hell。<br>2.如果几个异步操作之间并没有前后顺序之分（例如不需要前一个请求的结果作为后一个请求的参数）时，同样需要等待上一个操作完成再实行下一个操作。</p>
</blockquote>
<p>为了解决上述的问题，Promise 对象应运而生，在 EMCAScript 2015 当中已经成为标准。</p>
<h2 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h2><hr>
<blockquote>
<p>一个 Promise 对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了 Promise<br>对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。而且由于 Promise.all<br>这样的方法存在，可以让同时执行多个操作变得简单。接下来就来简单介绍 Promise 对象。</p>
</blockquote>
<p><strong>resolve 和 reject</strong></p>
<p>首先来看一段使用了 Promise 对象的代码。首先来看一段使用了 Promise 对象的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function helloWorld (ready) &#123;</div><div class="line">return new Promise(function (resolve, reject) &#123;</div><div class="line">if (ready) &#123;</div><div class="line">resolve(&quot;Hello World!&quot;);</div><div class="line">&#125; else &#123;</div><div class="line">reject(&quot;Good bye!&quot;);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">helloWorld(true).then(function (message) &#123;</div><div class="line">alert(message);</div><div class="line">&#125;, function (error) &#123;</div><div class="line">alert(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码实现的功能非常简单，helloWord 函数接受一个参数，如果为 true 就打印 “Hello World!”，如果为 false 就打印错误的信息。helloWord 函数返回的是一个 Promise 对象。</p>
<p>在 Promise 对象当中有两个重要方法————resolve 和 reject。</p>
<p>resolve 方法可以使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。</p>
<p>reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。</p>
<p><strong>Promise 的三种状态</strong></p>
<p>上面提到了 resolve 和 reject 可以改变 Promise 对象的状态，那么它究竟有哪些状态呢？</p>
<blockquote>
<p>Promise 对象有三种状态：</p>
<p>1.Fulfilled 可以理解为成功的状态<br>2.Rejected 可以理解为失败的状态 Pending 既不是 Fulfilld 也不是<br>3.Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态</p>
</blockquote>
<p>helloWorld 的例子中的 then 方法就是根据 Promise 对象的状态来确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject 时执行第二个函数（onRejected）。</p>
<p><strong>then 和 catch</strong></p>
<p><strong>then</strong></p>
<p>helloWorld 的例子当中利用了 then(onFulfilld, onRejected) 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下 then 方法同样可以用一个清晰的方式完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function printHello (ready) &#123;</div><div class="line">return new Promise(function (resolve, reject) &#123;</div><div class="line">if (ready) &#123;</div><div class="line">resolve(&quot;Hello&quot;);</div><div class="line">&#125; else &#123;</div><div class="line">reject(&quot;Good bye!&quot;);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function printWorld () &#123;</div><div class="line">alert(&quot;World&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function printExclamation () &#123;</div><div class="line">alert(&quot;!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">printHello(true)</div><div class="line">.then(function(message)&#123;</div><div class="line">alert(message);</div><div class="line">&#125;)</div><div class="line">.then(printWorld)</div><div class="line">.then(printExclamation);</div></pre></td></tr></table></figure>
<p>上述例子通过链式调用的方式，按顺序打印出了相应的内容。then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象。另外，在 then onFulfilled 的函数当中的返回值，可以作为后续操作的参数，因此上面的例子也可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">printHello(true).then(function (message) &#123;</div><div class="line">return message;</div><div class="line">&#125;).then(function (message) &#123;</div><div class="line">return message  + &apos; World&apos;;</div><div class="line">&#125;).then(function (message) &#123;</div><div class="line">return message + &apos;!&apos;;</div><div class="line">&#125;).then(function (message) &#123;</div><div class="line">alert(message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>catch</strong><br>catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch 的写法比一般的写法更加清晰明确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">somePromise().then(function () &#123;</div><div class="line">return anotherPromise();</div><div class="line">&#125;).then(function () &#123;</div><div class="line">return yetAnotherPromise();</div><div class="line">&#125;).catch(console.log.bind(console)); // &lt;-- this is badass</div></pre></td></tr></table></figure>
<p><strong>Promise.all 和 Promise.race</strong></p>
<p>Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function (resolve) &#123;</div><div class="line">setTimeout(function () &#123;</div><div class="line">resolve(&quot;Hello&quot;);</div><div class="line">&#125;, 3000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p2 = new Promise(function (resolve) &#123;</div><div class="line">setTimeout(function () &#123;</div><div class="line">resolve(&quot;World&quot;);</div><div class="line">&#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Promise.all([p1, p2]).then(function (result) &#123;</div><div class="line">console.log(result); // [&quot;Hello&quot;, &quot;World&quot;]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的例子模拟了传输两个数据需要不同的时长，虽然 p2 的速度比 p1 要快，但是 Promise.all 方法会按照数组里面的顺序将结果返回。</p>
<p>日常开发中经常会遇到这样的需求，在不同的接口请求数据然后拼合成自己所需的数据，通常这些接口之间没有关联（例如不需要前一个接口的数据作为后一个接口的参数），这个时候 Promise.all 方法就可以派上用场了。</p>
<p>还有一个和 Promise.all 相类似的方法 Promise.race，它同样接收一个数组，不同的是只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><hr>
<p><img src="https://segmentfault.com/img/bVmrXU" alt="这里写图片描述"><br>在浏览器端，一些主流的浏览器都已经可以使用 Promise 对象进行开发，在 Node.js 配合 babel 也可以很方便地使用。</p>
<p>如果要兼容旧的浏览器，建议可以寻找一些第三方的解决方案，例如 jQuery 的 $.Deferred。</p>
]]></content>
      
        
        <tags>
            
            <tag> js promise </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS中的回调函数]]></title>
      <url>http://yoursite.com/2017/03/24/JS%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>###关于回调函数</p>
<p>首先要了解，在 js 中，函数也是对象，可以赋值给变量，可以作为参数放在函数的参数列表中。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var doSomething = function(a,b)</div><div class="line">&#123;</div><div class="line">return a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的意思是定义一个匿名函数，这个匿名函数除了没有名字之外，其他跟普通的函数没有什么两样。然后把匿名函数赋值给变量doSomething。接下来我们调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(doSomething(2,3));//5</div></pre></td></tr></table></figure>
<p>回调函数，就是放在另外一个函数（如 parent）的参数列表中，作为参数传递给这个 parent，然后在 parent 函数体的某个位置执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var doit = function(callback)</div><div class="line">&#123;</div><div class="line">var a = 1,</div><div class="line">b = 2,</div><div class="line">c = 3;</div><div class="line">var t = callback(a,b,c);</div><div class="line">return t + 10;</div><div class="line">&#125;;</div><div class="line">var d = doit(function(x,y,z)&#123;</div><div class="line">return (x+y+z);</div><div class="line">&#125;);</div><div class="line">console.log(d);</div></pre></td></tr></table></figure>
<p>先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。</p>
<p>下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。</p>
<p>上述代码的执行过程是：</p>
<p>调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。</p>
<hr>
<p>传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。</p>
<p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用，甚至在这里强烈推荐使用。</p>
<p>因此，回调本质上是一种设计模式，并且jQuery(包括其他框架)的设计原则遵循了这个模式。</p>
<p>在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//基本方式</div><div class="line">function doSomething(callback) &#123;</div><div class="line">// … </div><div class="line">// Call the callback</div><div class="line">callback(&apos;stuff&apos;, &apos;goes&apos;, &apos;here&apos;);</div><div class="line">&#125; </div><div class="line">function foo(a, b, c) &#123;</div><div class="line">// I&apos;m the callback</div><div class="line">alert(a + &quot; &quot; + b + &quot; &quot; + c);</div><div class="line">&#125; </div><div class="line">doSomething(foo);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//匿名函数的形式</div><div class="line">function dosomething(damsg, callback)&#123;</div><div class="line">alert(damsg);</div><div class="line">if(typeof callback == &quot;function&quot;) </div><div class="line">callback();</div><div class="line">&#125; </div><div class="line">dosomething(&quot;回调函数&quot;, function()&#123;</div><div class="line">alert(&quot;和 jQuery 的 callbacks 形式一样!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>所以callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p>
<p><strong>回调什么时候执行</strong></p>
<p>回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。</p>
<p><strong>回调函数的使用场合</strong></p>
<p>资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。</p>
<p>DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。</p>
<p>setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现</p>
<p>链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。</p>
<p><strong>回调函数的传递</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.get(&apos;myhtmlpage.html&apos;, myCallBack);//这是对的</div><div class="line">$.get(&apos;myhtmlpage.html&apos;, myCallBack(&apos;foo&apos;, &apos;bar&apos;));//这是错的，那么要带参数呢？</div><div class="line">$.get(&apos;myhtmlpage.html&apos;, function()&#123;//带参数的使用函数表达式</div><div class="line">myCallBack(&apos;foo&apos;, &apos;bar&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>另外，最好保证回调存在且必须是函数引用或者函数表达式： (callback &amp;&amp; typeof(callback) ===<br>“function”) &amp;&amp; callback();</p>
</blockquote>
<hr>
<p>###回调函数使用实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//使用call方法</div><div class="line">function Thing(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line">Thing.prototype.doSomething = function(callback) &#123;</div><div class="line">// Call our callback, but using our own instance as the context</div><div class="line">callback.call(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var t = new Thing(&apos;Joe&apos;);</div><div class="line">t.doSomething(foo); // Alerts &quot;Joe&quot; via `foo`</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//传参数</div><div class="line">function Thing(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line">Thing.prototype.doSomething = function(callback, salutation) &#123;</div><div class="line">// Call our callback, but using our own instance as the context</div><div class="line">callback.call(this, salutation);</div><div class="line">&#125; </div><div class="line">function foo(salutation) &#123;</div><div class="line">alert(salutation + &quot; &quot; + this.name);</div><div class="line">&#125; </div><div class="line">var t = new Thing(&apos;Joe&apos;);</div><div class="line">t.doSomething(foo, &apos;Hi&apos;); // Alerts &quot;Hi Joe&quot; via `foo`</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//使用apply传参</div><div class="line">function Thing(name) &#123;</div><div class="line">this.name = name;</div><div class="line">&#125;</div><div class="line">Thing.prototype.doSomething = function(callback) &#123;</div><div class="line">// Call our callback, but using our own instance as the context</div><div class="line">callback.apply(this, [&apos;Hi&apos;, 3, 2, 1]);</div><div class="line">&#125; </div><div class="line">function foo(salutation, three, two, one) &#123;</div><div class="line">alert(salutation + &quot; &quot; + this.name + &quot; – &quot; + three + &quot; &quot; + two + &quot; &quot; + one);</div><div class="line">&#125; </div><div class="line">var t = new Thing(&apos;Joe&apos;);</div><div class="line">t.doSomething(foo); // Alerts &quot;Hi Joe – 3 2 1&quot; via `foo`</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//假如提供的数据源是一整数,为某学生的分数,当num&lt;=0,由底层处理,当n&gt;0时由高层处理.</div><div class="line">//将下面这个函数拷贝下来存盘为1.js</div><div class="line">function f(num,callback)&#123;</div><div class="line">if(num&lt;0) &#123; </div><div class="line">alert(&quot;调用低层函数处理!&quot;);</div><div class="line">alert(&quot;分数不能为负,输入错误!&quot;); </div><div class="line">&#125;else if(num==0)&#123;</div><div class="line">alert(&quot;调用低层函数处理!&quot;);</div><div class="line">alert(&quot;该学生可能未参加考试！&quot;);</div><div class="line">&#125;else&#123;</div><div class="line">alert(&quot;调用高层函数处理!&quot;);</div><div class="line">callback();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//将下面这个test.html文件存盘与1.js在一个目录下：</div><div class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</div><div class="line">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;</div><div class="line">&lt;script src=&quot;1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;title&gt;无标题文档&lt;/title&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function test()&#123;</div><div class="line">var p=document.getElementById(&quot;pp&quot;);</div><div class="line">pp.innerText=&quot;&quot;;</div><div class="line">var num=document.getElementById(&quot;score&quot;).value;</div><div class="line">f(num,function()&#123; //匿名高层处理函数</div><div class="line">if(num&lt;60) alert(&quot;未及格！&quot;);</div><div class="line">else if(num&lt;=90) alert(&quot;该生成绩优良！&quot;);</div><div class="line">else alert(&quot;该生成绩优秀!&quot;); &#125;)</div><div class="line">pp.innerText=&quot;by since1978 qq558064!&quot;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;</div><div class="line">回调函数示例:当学生成绩score&lt;=0分时候，由底层处理；当score&gt;0时，由高层处理。</div><div class="line">&lt;/p&gt;</div><div class="line">请输入学生成绩&lt;input type=&quot;text&quot; id=&quot;score&quot;&gt; </div><div class="line">&lt;input type=&quot;button&quot; onClick=&quot;test()&quot; value=&quot; 看看结果&quot;&gt;</div><div class="line">&lt;p id=&quot;pp&quot;&gt;&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//node.js中出现的回调函数</div><div class="line">app.use(function(req, res, next) &#123;</div><div class="line">var err = new Error(&apos;Not Found&apos;);</div><div class="line">err.status = 404;</div><div class="line">next(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<p>###小结<br>回调函数是实现js异步编程的四种方法之一，但并不推荐用此方法： 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<p>不过正如上文所说，回调函数不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p>
<blockquote>
<p>在javascript中回调函数非常重要，它们几乎无处不在</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> js 回调函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么是动态HTML？-DHTML]]></title>
      <url>http://yoursite.com/2017/03/23/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81HTML%EF%BC%9F-DHTML/</url>
      <content type="html"><![CDATA[<p>DHTML是Dynamic HTML的简称，中文译为“动态超文本标记语言”，主要用途是提**TML页面的交互性和可操作性。它是建立在传统HTML基础上的客户端动态技术，是一种技术的总称，它通过HTML、VBScript、JavaScript邮和CSS等语言、技术使网页能够具有动态交互功能。虽然HTML语言可以制作出具有复杂格式的网页，但这样制作出来的网页只包含静态内容。凡是网页上有任何信息需要更新，浏览器就必须从服务器上重新下载整个网页，因而给网络造成极大的负担。它是建立在传统HTML基础上的客户端动态技术。</p>
<p>DHTML实现了网页从Web服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。这是近年来网络飞速发展进程中员振奋人心也最具实用性的技术之一。DHTML是一种通过各种技术的综合发展而来的概念，这些技术包括JavaScript、VBScript、DOM(Document Object Mode，文档对象模型)、Layers和CSS(Cascading Style Sheets，层又叠样式表)等。目前IE4．0以上的大多数浏览器都加入了对DHTML的支持，主要包括以下内容：</p>
<blockquote>
<p>①动态内容(Dynamic Content)：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。​</p>
<p>②动态排版样式(Dynamic Style<br>Sheets)：W3C的CSS样式表提供了设定HTML标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> HTML DHTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS中this的指向]]></title>
      <url>http://yoursite.com/2017/03/22/JS%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
      <content type="html"><![CDATA[<p><strong>this是Javascript语言的一个关键字。</strong> </p>
<p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123; </div><div class="line"></div><div class="line">　　　　this.x = 1; </div><div class="line"></div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>
</blockquote>
<p>下面分四种情况，详细讨论this的用法。</p>
<p><strong>情况一：纯粹的函数调用</strong> </p>
<p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象。</p>
<p>请看下面这段代码，它的运行结果是1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function test()&#123; </div><div class="line"></div><div class="line">　　　　this.x = 1; </div><div class="line"></div><div class="line">　　　　alert(this.x); </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　test(); // 1</div></pre></td></tr></table></figure>
<p>为了证明this就是全局对象，我对代码做一些改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 1; </div><div class="line"></div><div class="line">　　function test()&#123; </div><div class="line"></div><div class="line">　　　　alert(this.x); </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　test(); // 1</div></pre></td></tr></table></figure>
<p>运行结果还是1。再变一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = 1; </div><div class="line"></div><div class="line">　　function test()&#123; </div><div class="line"></div><div class="line">　　　　this.x = 0; </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　test(); </div><div class="line"></div><div class="line">　　alert(x); //0</div></pre></td></tr></table></figure>
<p><strong>情况二：作为对象方法的调用</strong> </p>
<p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function test()&#123; </div><div class="line"></div><div class="line">　　　　alert(this.x); </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　var o = &#123;&#125;; </div><div class="line"></div><div class="line">　　o.x = 1; </div><div class="line"></div><div class="line">　　o.m = test; </div><div class="line"></div><div class="line">　　o.m(); // 1</div></pre></td></tr></table></figure>
<p><strong>情况三 作为构造函数调用</strong> </p>
<p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function test()&#123; </div><div class="line"></div><div class="line">　　　　this.x = 1; </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　var o = new test(); </div><div class="line"></div><div class="line">　　alert(o.x); // 1</div></pre></td></tr></table></figure>
<p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = 2; </div><div class="line"></div><div class="line">　　function test()&#123; </div><div class="line"></div><div class="line">　　　　this.x = 1; </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　var o = new test(); </div><div class="line"></div><div class="line">　　alert(x); //2</div></pre></td></tr></table></figure>
<p>运行结果为2，表明全局变量x的值根本没变。</p>
<p><strong>情况四 apply调用</strong></p>
<p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数</p>
<p>　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var x = 0; </div><div class="line"></div><div class="line">　　function test()&#123; </div><div class="line"></div><div class="line">　　　　alert(this.x); </div><div class="line"></div><div class="line">　　&#125; </div><div class="line"></div><div class="line">　　var o=&#123;&#125;; </div><div class="line"></div><div class="line">　　o.x = 1; </div><div class="line"></div><div class="line">　　o.m = test; </div><div class="line"></div><div class="line">　　o.m.apply(); //0</div></pre></td></tr></table></figure>
<p>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 </p>
<p>如果把最后一行代码修改为 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.m.apply(o); //1</div></pre></td></tr></table></figure>
<p>运行结果就变成了1，证明了这时this代表的是对象o</p>
]]></content>
      
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ js中Math.random()生成指定范围数值的随机数]]></title>
      <url>http://yoursite.com/2017/03/20/js%E4%B8%ADMath-random-%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E6%95%B0%E5%80%BC%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      <content type="html"><![CDATA[<p><strong>定义和用法</strong></p>
<p>random() 方法可返回介于 0 ~ 1 之间的一个随机数。</p>
<p><strong>语法</strong></p>
<p>Math.random()</p>
<p><strong>返回值</strong></p>
<p>0.0 ~ 1.0 之间的一个伪随机数。</p>
<p><strong>实例</strong></p>
<p>在本例中，我们将取得介于 0 到 1 之间的一个随机数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">document.write(Math.random());</div><div class="line">&lt;/script&gt;</div><div class="line">// 输出：</div><div class="line">0.15246391076246546</div></pre></td></tr></table></figure>
<p><strong>关于如何生成指定范围值的随机数？</strong></p>
<blockquote>
<p>利用 parseInt()、Math.floor() 或者 Math.ceil()进行四舍五入处理</p>
</blockquote>
<p>我们看到，直接使用Math.random()方法，生成的是一个小于1的数，所以：</p>
<blockquote>
<p>Math.random()*5</p>
</blockquote>
<p>得到的结果是一个小于5的随机数。而我们通常希望得到的是0-5之间的整数，所以我们需要对得到的结果四舍五入处理一下，从而得到我们期望的整数。parseInt()、Math.floor()和Math.ceil()都可以起到四舍五入的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var randomNum = Math.random()*5;</div><div class="line">alert(randomNum); // 2.9045290905811183 </div><div class="line">alert(parseInt(randomNum,10)); // 2</div><div class="line">alert(Math.floor(randomNum)); // 2</div><div class="line">alert(Math.ceil(randomNum)); // 3</div></pre></td></tr></table></figure></p>
<p>由测试的代码我们可以看到，<code>parseInt()</code>和<code>Math.floor()</code>的效果是一样的，都是向下取整数部分。所以<code>parseInt(Math.random()*5,10)</code>和<code>Math.floor(Math.random()*5)</code>都是生成的0-4之间的随机数，<code>Math.ceil(Math.random()*5)</code>则是生成的1-5之间的随机数。</p>
<p><strong>生成指定范围数值随机数</strong></p>
<p>如果你希望生成1到任意值的随机数，公式就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// max - 期望的最大值</div><div class="line">parseInt(Math.random()*max,10)+1;</div><div class="line">Math.floor(Math.random()*max)+1;</div><div class="line">Math.ceil(Math.random()*max);</div></pre></td></tr></table></figure>
<p>如果你希望生成0到任意值的随机数，公式就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// max - 期望的最大值</div><div class="line">parseInt(Math.random()*(max+1),10);</div><div class="line">Math.floor(Math.random()*(max+1));</div></pre></td></tr></table></figure>
<p>如果你希望生成任意值到任意值的随机数，公式就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// max - 期望的最大值</div><div class="line">// min - 期望的最小值 </div><div class="line">parseInt(Math.random()*(max-min+1)+min,10);</div><div class="line">Math.floor(Math.random()*(max-min+1)+min);</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js部署到阿里云服务器]]></title>
      <url>http://yoursite.com/2017/03/16/nodejs%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>整个部署过程学到了不少东西，记录一下。</p>
<blockquote>
<p>参考了以下文章：<br> <a href="http://itbilu.com/other/relate/NJ2TJohl.html" target="_blank" rel="external">http://itbilu.com/other/relate/NJ2TJohl.html</a><br><a href="https://segmentfault.com/a/1190000004051670" target="_blank" rel="external">https://segmentfault.com/a/1190000004051670</a><br><a href="http://borninsummer.com/2015/06/17/notes-on-developing-nodejs-webapp/" target="_blank" rel="external">http://borninsummer.com/2015/06/17/notes-on-developing-nodejs-webapp/</a><br><a href="https://bbs.aliyun.com/read/146189.html" target="_blank" rel="external">https://bbs.aliyun.com/read/146189.html</a></p>
</blockquote>
<p><strong>1. 到阿里云购买云服务器 ECS 。</strong><br><a href="https://www.aliyun.com/product/ecs" target="_blank" rel="external">https://www.aliyun.com/product/ecs</a><br>如果是在校学生，在淘宝有实名认证，且在学信网有注册，可以试试抢学生的首月优惠套餐。<a href="https://www.aliyun.com/act/aliyun/campus.html" target="_blank" rel="external">https://www.aliyun.com/act/aliyun/campus.html</a><br>作为一个穷逼+不熟悉服务器配置的菜鸟。选了最便宜的套餐：<br>CPU： 1核 / 内存： 1024 MB / 带宽：1Mbps / 操作系统： CentOS 7.0<br>购买环节会设置 ssh 登陆密码，记下密码。<br>登陆到阿里云，查看购买的实例。<br>注意公网 IP，下一步会用到<br><img src="http://img.blog.csdn.net/20170212142340544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW91bWFvYnVjaGl5dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="购买的实例"><br><strong>2. 登陆服务器</strong><br>sudo ssh 你的服务器ip地址</p>
<blockquote>
<p>关于 ssh 登陆，具体可以看<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a> 这篇文章。</p>
</blockquote>
<p>提示输入mac的密码，提示输入服务器密码。<br>输入后连接成功并显示服务器信息，如下：<br><img src="http://img.blog.csdn.net/20170212142549327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW91bWFvYnVjaGl5dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="成功的状态"></p>
<p>登陆服务器后。这里对于我这个 Linux 菜鸟有个大坑………就是 Linux 系统常见的目录结构和文件放置区域。<br>使用 root 用户身份登陆后，会直接进入到下图 红色箭头标出的 root 目录下。先 cd .. 跳转到上一层, 再 ls -a ，就可以看到类似下图的目录结构了。</p>
<p><img src="http://img.blog.csdn.net/20170212142640688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW91bWFvYnVjaGl5dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片引用自《鸟哥的Linux》"></p>
<p><strong>3.安装 node 和 mongodb</strong></p>
<blockquote>
<p>node – 编译后二进制文件应在/usr/local/bin/node 下<br> mongodb –安装在/usr/local/mongodb 下</p>
</blockquote>
<p>下面就一步一步来，首先升级CentOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y update</div></pre></td></tr></table></figure>
<p>升级后，跳转到 /usr/local/src , 这个文件夹通常用来存放软件源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/src</div></pre></td></tr></table></figure>
<p>下载 nodejs 代码，也可以使用scp命令直接上传，因为下载实在太慢了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http://nodejs.org/dist/v0.12.5/node-v0.12.5.tar.gz</div><div class="line">//注*根据最新版本号为准</div></pre></td></tr></table></figure>
<p>解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xzvf node-v0.12.5.tar.gz</div></pre></td></tr></table></figure>
<p>进入解压后的文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd node-v0.12.5</div></pre></td></tr></table></figure>
<p>执行配置脚本来进行编译预处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure</div></pre></td></tr></table></figure>
<p>编译源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make</div><div class="line">//注*这个时间可能会很久</div></pre></td></tr></table></figure>
<p>当编译完成后，需要使之在系统范围内可用, 编译后的二进制文件将被放置到系统路径，默认情况下，Node二进制文件应该放在/user/local/bin/node文件夹下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure>
<p>安装 express 和 forever，这两个模块都推荐 global 安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm -g install express forever</div></pre></td></tr></table></figure>
<p>建立超级链接, 不然 sudo node 时会报 “command not found”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /usr/local/bin/node /usr/bin/node</div><div class="line">sudo ln -s /usr/local/lib/node /usr/lib/node</div><div class="line">sudo ln -s /usr/local/bin/npm /usr/bin/npm</div><div class="line">sudo ln -s /usr/local/bin/node-waf /usr/bin/node-waf</div><div class="line">sudo ln -s /usr/local/bin/forever /usr/bin/forever</div></pre></td></tr></table></figure>
<p>Nodejs到这里就基本安装完成了。</p>
<p><strong>下面来安装mongodb</strong></p>
<blockquote>
<p>软件安装位置：/usr/local/mongodb<br>数据存放位置：/var/mongodb/data<br>日志存放位置：/var/mongodb/logs</p>
</blockquote>
<p>首先下载安装包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local</div><div class="line">wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.4.9.tgz</div></pre></td></tr></table></figure>
<p>解压安装包，重命名文件夹为mongodb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf mongodb-linux-x86_64-2.6.0.tgz</div><div class="line">mv mongodb-linux-x86_64-2.6.0 mongodb</div></pre></td></tr></table></figure>
<p>创建数据和日志存放目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /var/mongodb</div><div class="line">mkdir /var/mongodb/data</div><div class="line">mkdir /var/mongodb/logs</div></pre></td></tr></table></figure>
<p>打开rc.local文件，添加CentOS开机启动项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div></pre></td></tr></table></figure>
<p>将mongodb启动命令追加到本文件中，让mongodb开机自启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath </div><div class="line">/var/mongodb/logs/log.log -fork</div></pre></td></tr></table></figure>
<p>关闭 vim 后，直接手动启动mongodb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath </div><div class="line">/var/mongodb/logs/log.log -fork</div></pre></td></tr></table></figure>
<p>看到类似的信息，说明已启动成功。我在这里发了个傻，以为26308是port号，导致后面设置port时折腾了好久。其实这里的 forked process 和 port 号是两个东西， 这个是程序本身在Server上的进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forked process: 26308</div></pre></td></tr></table></figure>
<p>启动mongo shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/mongodb/bin/</div><div class="line">./mongo</div></pre></td></tr></table></figure>
<p>在 mongo shell 中创建管理员及数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">use admin //admin 数据库</div><div class="line">db.createUser(&#123;</div><div class="line">user: &quot;用户名&quot;,</div><div class="line">pwd:&quot;登陆密码&quot;,</div><div class="line">roles:[&quot;userAdminAnyDatabase&quot;] //超级管理员</div><div class="line">&#125;)</div><div class="line"></div><div class="line">use databaseFoo //nodeapp 要连接的数据库</div><div class="line">db.createUser(&#123;</div><div class="line">user: &quot;用户名&quot;,</div><div class="line">pwd:&quot;登陆密码&quot;,</div><div class="line">roles:[&quot;readWrite&quot;] //读写权限</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>到这里 mongodb 基本已经安装设置完成了。具体数据的迁移导入可自行研究。</p>
<p><strong>4.配置及启动node app</strong></p>
<p>我们把 nodeapp 的程序放在 /home 下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /home</div></pre></td></tr></table></figure>
<p>我使用 <a href="http://git.oschina.net/" target="_blank" rel="external">http://git.oschina.net/</a> 管理代码。它的私有库是免费的。基本操作和 github 一样。<br>复制代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://git.oschina.net/xxxxxxx/nodeapp.git   //你的repo地址</div></pre></td></tr></table></figure>
<p>注*同时可以使用图形化程序进行上传如File Zilla<img src="http://img.blog.csdn.net/20170212201742447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW91bWFvYnVjaGl5dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="FZ"><br>进入 nodeapp 文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd nodeapp</div></pre></td></tr></table></figure>
<p>（若后续代码变更，提交到 git repo 后直接git pull即可部署代码）<br>安装nodeapp的所有依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
<p>在启动文件 ( 我的是 app.js ) 中设置数据库连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim app.js</div></pre></td></tr></table></figure>
<p>数据库连接类似下面的格式，由于数据库安装在同一服务器，因此 host 为127.0.0.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var dbUrl = &apos;mongodb://用户名:登陆密码@127.0.0.1/databaseFoo&apos;;</div><div class="line">mongoose.connect(dbUrl)</div></pre></td></tr></table></figure>
<p>这里要注意，如果直接 npm start 或 node app.js 启动，则一旦退出 ssh 远程登陆，nodeapp 就会停止运行。因此我们使用 forever 启动 nodeapp。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_ENV=production forever start app.js</div></pre></td></tr></table></figure>
<blockquote>
<p>如今可以使用PM2启动程序，步骤如下：<br>使用它要先安装它，用root账号和全局模式安装一下：<br><code>npm install -g pm2</code><br>用它来启动程序（在当前目录下可以直接启动）<br><code>pm2 start app.js --name uops</code></p>
</blockquote>
<p>在蹚过无数坑后，项目部署成功。用浏览器打开 公网IP:端口号 即可看到 nodeapp 的首页</p>
]]></content>
      
        
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2017/01/28/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
