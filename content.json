{"meta":{"title":"某猫のBlog","subtitle":null,"description":null,"author":"某猫","url":"https://www.moumaobuchiyu.com"},"pages":[{"title":"friends","date":"2017-04-19T05:53:55.000Z","updated":"2017-04-19T05:53:55.000Z","comments":true,"path":"friends/index.html","permalink":"https://www.moumaobuchiyu.com/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-20T12:57:33.000Z","updated":"2017-05-10T07:58:19.000Z","comments":true,"path":"about/index.html","permalink":"https://www.moumaobuchiyu.com/about/index.html","excerpt":"","text":"关于主题这是某猫开发的hexo主题——Vateral powered by hexo &amp; Materialize 基于material design 兼容目前大部分设备，从电脑，到平板，再到手机 欢迎你的使用以及意见反馈 关于我96年 双鱼男 喜欢摄影 以及前端开发 目前就读于华东交通大学 软件工程专业 如何联系我QQ：1195358569 Email：1195358569@qq.com 微信：wangchengyu1231 如何获取友情链接私信我 或者发邮件 格式如下： 你的昵称：网址：一段简介："},{"title":"photo","date":"2017-04-19T05:59:59.000Z","updated":"2017-04-19T05:59:59.000Z","comments":true,"path":"photo/index.html","permalink":"https://www.moumaobuchiyu.com/photo/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2017-05-10T12:07:14.000Z","updated":"2017-05-10T12:07:14.000Z","comments":true,"path":"2017/05/10/test/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/05/10/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript重点总结(不定期更新)","slug":"JavaScript重点总结-不定期更新","date":"2017-04-27T07:33:29.000Z","updated":"2017-05-08T03:07:54.000Z","comments":true,"path":"2017/04/27/JavaScript重点总结-不定期更新/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/04/27/JavaScript重点总结-不定期更新/","excerpt":"Javascript Hoisting：变量提升 相关资料-1 函数声明和函数表达式的区别 相关资料-1","text":"Javascript Hoisting：变量提升 相关资料-1 函数声明和函数表达式的区别 相关资料-1 javascript closure ：闭包 相关资料-1相关资料-2 this指针 相关资料-1相关资料-2 ES6—Promise 相关资料-1 call() &amp; apply() &amp; bind() 相关资料-1相关资料-2 prototype属性 相关资料-1 函数防抖与节流 相关资料-1相关资料-2相关资料-3相关资料-4相关资料-5","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.moumaobuchiyu.com/tags/js/"},{"name":"js基础","slug":"js基础","permalink":"https://www.moumaobuchiyu.com/tags/js基础/"},{"name":"js难点总结","slug":"js难点总结","permalink":"https://www.moumaobuchiyu.com/tags/js难点总结/"}]},{"title":"在服务器上搭建hexo博客","slug":"在服务器上搭建hexo博客","date":"2017-04-21T02:41:30.000Z","updated":"2017-05-08T02:49:21.000Z","comments":true,"path":"2017/04/21/在服务器上搭建hexo博客/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/04/21/在服务器上搭建hexo博客/","excerpt":"随着Vateral主题的开发接近了尾声，在对主题速度优化的时候发现之前用的githubpage问题多多：首先就是因为在国内的原因，访问速度本身就很慢，曾经有次加载一张16kb的图标时间耗费了26s！！？","text":"随着Vateral主题的开发接近了尾声，在对主题速度优化的时候发现之前用的githubpage问题多多：首先就是因为在国内的原因，访问速度本身就很慢，曾经有次加载一张16kb的图标时间耗费了26s！！？其次，在对资源做CDN托管加速时，域名是需要备案的，显然githubpage也是做不了的；所以果断舍弃了这个把hexo搭建到了我的阿里云服务器上 总体来说还是比把hexo搭建到github上要复杂一些的，期间遇到了不少坑，也参考了很多资料，这里详细的总结一下具体的步骤。 hexo的架构 首先我们要理解hexo是如何实现静态博客通过服务器访问的 通过上图我们可以知道，整个流程就是在本地通过hexo g 渲染博客的静态文件，然后通过hexo d 把静态文件 push到服务器上我们自己创建的git仓库,服务器再通过 git-hooks 同步网站根目录，这样就可以访问了 搭建流程 第一步： 安装node.js以及本地Hexo初始化第二步： 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户第三步： 使用Git自动化部署发布博客 本地环境 安装node.js$ brew install node 初始化Hexo博客首先创建 你的Hexo 目录 $ mkdir &quot;your hexo dir name&quot;//创建一个自定义的hexo目录，比如我就在用户根目录创建了一个myhexo文件夹（macOS) $ cd &quot;your hexo dir name&quot;//进入到刚刚创建的目录 然后安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行 sudo npm install -g hexo-cli 初始化该文件夹 hexo init 安装hexo的扩展插件 npm install 等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。 npm install hexo-deployer-git --save npm install hero-server --save 以及一些其他插件（*非必选） npm install hexo-admin --save npm install hexo-generator-archive --save npm install hexo-generator-feed --save npm install hexo-generator-search --save npm install hexo-generator-tag --save npm install hexo-generator-sitemap --save 到这里hexo的本地搭建已经基本结束了，快来新建一个文章并在本地启动吧~ 生成自己的第一篇文章使用 hexo new &lt;文章名称&gt; 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。（*在hexo目录下执行命令） hexo new &quot;hello Hexo&quot; 执行该命令后在hexo目录下的 sources/_posts文件夹里生成了刚刚创建的helloHexo.md的markdown文件，然后就可以通过本地或者在线的markdown编辑器就可以创作自己的博客了~ 编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server hexo g hexo server 打开 http://localhost:4000 如果看到 hexo 的初始页面证明安装成功。 生成ssh公钥密钥$ cd ~/.ssh $ ssh-keygen 它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空；具体生产方法可以参考这里 这个公钥将会复制到服务器的证书中，添加公钥之后可以防止每次 push 都输入密码。 至此，本地环境的搭建已经基本结束。 服务器环境搭建 安装nginx因为我们是拿nginx做 Web 服务器，所以我们需要安装部署好nginx，如果没有安装，推荐使用LNMP一键安装包 我们可以专门为hexo创建一个部署目录，比如我创建了/home/www/hexo文件夹，并把nginx的配置文件nginx.conf中的部署目录改为/home/www/hexo，配置文件一般在/usr/local/nginx/conf里；同样可以使用默认目录，nginx的默认目录为/var/www/html，如果使用LNMP一键安装包，则默认的部署目录为/home/wwwroot/default 安装node.js$ curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash - $ apt-get install -y nodejs 如果遇到问题可以参考Node.js部署到阿里云服务器里边有更详细的关于node.js的步骤 安装git$ apt-get install git 创建一个git用户$ sudo adduser git 虽说现在的仓库只有我们自己在使用，新建一个 git 用户显得不是很有必要，但是为了安全起见，还是建议使用单独的 git 用户来专门运行git 服务 添加证书登录把刚在在本地创建或者已经拥有的公钥，也就是 ~/.ssh/id_rsa.pub 文件里的内容添加到服务器的 /home/git/.ssh/authorized_keys 文件中，如上所说，添加公钥之后可以防止每次 push 都输入密码。（*可以直接执行cat ~/.ssh/id_rsa.pub | pbcopy 复制） ###初始化 Git 仓库可以将git仓库放到自定义位置，我是将其放在 /var/repo/blog.git 目录下的 $ sudo mkdir /var/repo $ cd /var/repo $ sudo git init --bare blog.git 使用 –bare 参数，Git 就会创建一个裸仓库，裸仓库没有工作区，我们不会在裸仓库上进行操作，它只为共享而存在。 配置 git hooks 我们这里要使用的是 post-receive 的 hook，这个 hook 会在整个 git 操作过程完结以后被运行，关于 hooks的详情内容可以参考这里。 在 blog.git/hooks 目录下新建一个 post-receive 文件 $ cd /var/repo/blog.git/hooks 编辑这个文件 $ vim post-receive 在 post-receive 文件中写入如下内容 #!/bin/sh git --work-tree=/home/www/hexo --git-dir=/var/repo/blog.git checkout -f 注意，/home/www/hexo 要换成你自己的部署目录，正如上文所说，我是的配置目录是/home/www/hexo。/var/repo/blog.git是git仓库的位置。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。 设置这个文件的可执行权限 chmod +x post-receive 改变 blog.git 目录的拥有者为 git 用户$ sudo chown -R git:git blog.git 禁用 git 用户的 shell 登录权限出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd 来实现 vim /etc/passwd 将 git:x:1001:1001:,,,:/home/git:/bin/bash 改成 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll。 至此，服务器环境的搭建已经基本结束。 配置本地_config.yml文件,完成自动化部署 现在配置 hexo 的 deploy。修改 hexo 目录下的 _config.yml 找到 deploy, 修改为： deploy: type: git repo: git@www.moumaobuchiyu.com:/var/repo/blog.git branch: master repo 的地址为你自己的地址以及 git 仓库目录 至此，我们的 hexo 自动部署已经全部配置好了 开始使用新建文章： $ hexo new &quot;post name&quot; 生成 &amp; 部署： $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 参考在 VPS 上搭建 Hexo 博客，使用 Git 部署阿里云VPS搭建自己的的Hexo博客使用 Git Hook 自动部署 Hexo 到个人 VPS使用git hooks进行hexo博客自动化部署","categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.moumaobuchiyu.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.moumaobuchiyu.com/tags/hexo/"},{"name":"服务器","slug":"服务器","permalink":"https://www.moumaobuchiyu.com/tags/服务器/"}]},{"title":"大学算是毕业了","slug":"大学算是毕业了","date":"2017-04-18T15:41:28.000Z","updated":"2017-04-25T11:21:31.000Z","comments":true,"path":"2017/04/18/大学算是毕业了/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/04/18/大学算是毕业了/","excerpt":"","text":"上了两年多大学，现在算是基本毕业了吧现在被学校忽悠到什么杰普软件公司培训几个月还是培训JavaEE。。。。折腾了几天才安顿到苏州附近的昆山到这里的两天更新了友链和摄影界面 这里的环境不错，适合跑步","categories":[{"name":"日常","slug":"日常","permalink":"https://www.moumaobuchiyu.com/categories/日常/"}],"tags":[{"name":"杰普","slug":"杰普","permalink":"https://www.moumaobuchiyu.com/tags/杰普/"},{"name":"浦东软件园","slug":"浦东软件园","permalink":"https://www.moumaobuchiyu.com/tags/浦东软件园/"}]},{"title":"历经半个月 终于用上了自己开发的hexo主题","slug":"历经半个月-终于用上了自己开发的hexo主题","date":"2017-04-11T06:15:09.000Z","updated":"2017-04-25T11:22:05.000Z","comments":true,"path":"2017/04/11/历经半个月-终于用上了自己开发的hexo主题/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/04/11/历经半个月-终于用上了自己开发的hexo主题/","excerpt":"","text":"填了半个月的坑，终于用上了自己开发的hexo主题–vateral在这之间接触hexo这个框架不到一周的时间，并且使用了vio喵的material主题很喜欢这个主题的风格，也就有了开发自己主题的打算这也是为什么vateral中在样式上会有些material的影子熬了几次夜，终于这个主题实现了一些基本的功能，其中遇到了好多问题，也一点点解决了，而且不得不说还把新买的电脑的键盘敲坏了….不过想想一开始的样子，心里还是蛮欣慰的，填坑中也学到了不少东西，然而主题还没有正式发布到hexo的主题里边，有文档要写，服务器还要配置环境，还要修改bug，和更多功能的开发。 主题初始的样式 没过几天就要去上海培训了，打算最近完善好主题并且更新到1.0.0的正式版，以及发布到hexo的官方主题文档上。不知道会不会有人用这个主题23333，毕竟接触hexo这个博客框架的人还不多别说博文少哦，时间都拿去开发博客了，还有主题的样式和布局大部分也是自己设计的，不要嫌弃丑啊哈哈","categories":[{"name":"日常","slug":"日常","permalink":"https://www.moumaobuchiyu.com/categories/日常/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"https://www.moumaobuchiyu.com/tags/hexo主题/"},{"name":"vateral","slug":"vateral","permalink":"https://www.moumaobuchiyu.com/tags/vateral/"}]},{"title":"meta标签总结","slug":"meta标签总结","date":"2017-04-05T03:28:28.000Z","updated":"2017-05-10T11:17:43.000Z","comments":true,"path":"2017/04/05/meta标签总结/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/04/05/meta标签总结/","excerpt":"","text":"定义 meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 以上是w3c上的解释。元信息，是用来描述数据的数据，也就是用来描述当前页面的一些信息。例如：定义页面的说明，关键字、作者等等。 包含的属性1.name属性 name 属性提供了名称/值对中的名称（而后面要说的content属性则是该名称对应的值）。假如我们把页面想象成一个我们生活中的实物的话，拿个人简历来作类比，诸如姓名、性别、籍贯、技能、项目经验等等这些都可以看做是个人简历的name属性，content属性相当于这些名称对应的值。 &lt;meta name=\"名称\" content=\"具体的描述\"> 2.content属性 content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。content 属性始终要和 name 属性或 http-equiv 属性一起使用。 &lt;meta name=\"名称\" content=\"具体的描述\"> 3.http-equiv属性 equiv是equivalent的简写，是相等的，等价物的意思。不难理解，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 &lt;meta http-equiv=\"名称\" content=\"具体的描述\"> 常用的标签使用 HTML5 doctype，不区分大小写。 &lt;!DOCTYPE html> //使用 HTML5 doctype，不区分大小写 声明文档使用的字符编码 &lt;meta http-equiv=\"content-Type\" content=\"text/html;charset=utf-8\"> //旧的HTML，不推荐 &lt;meta charset=\"utf-8\"> //HTML5设定网页字符集的方式，推荐使用UTF-8 renderer(双核浏览器渲染方式) 说明：renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。 &lt;meta name=\"renderer\" content=\"webkit\"> //默认webkit内核 &lt;meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式 &lt;meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式 ```html X-UA-Compatible(浏览器采取何种版本渲染当前页面) > 说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。） ```html &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/> //指定IE和Chrome使用最新版本渲染当前页面 refresh(自动刷新并指向某页面) 说明：网页将在设定的时间内，自动刷新并调向设定的网址。 &lt;meta http-equiv=\"Refresh\" content=\"5;url=http://www.w3school.com.cn\" /> //5秒后重定向到w3c官网 SEO 优化 页面描述 每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签 &lt;meta name=\"description\" content=\"不超过150个字符\"> &lt;!-- 页面描述 --> 页面关键词 &lt;meta name=\"keywords\" content=\"\"> &lt;!-- 页面关键词 --> 定义页面标题 &lt;title>标题&lt;/title> 定义网页作者 &lt;meta name=\"author\" content=\"name, email@gmail.com\"> &lt;!-- 网页作者 --> 定义网页搜索引擎索引方式，robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 &lt;meta name=\"robots\" content=\"index,follow\"> &lt;!-- 搜索引擎抓取 --> 为移动设备添加 viewport &lt;meta name =\"viewport\" content =\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"> width=device-width 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 content 参数： width viewport 宽度(数值/device-width) height viewport高度(数值/device-height) initial-scale 初始缩放比例 maximum-scale 最大缩放比例minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) minimal-ui iOS7.1 beta 2 中新增属性（注意：iOS8 中已经删除），可以在页面加载时最小化上下状态栏。这是一个布尔值，可以直接这样写： 以及一些其他的标签&lt;!-- 声明文档使用的字符编码 --> &lt;meta charset='utf-8'> &lt;!-- 优先使用 IE 最新版本和 Chrome --> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/> &lt;!-- 页面描述 --> &lt;meta name=\"description\" content=\"不超过150个字符\"/> &lt;!-- 页面关键词 --> &lt;meta name=\"keywords\" content=\"\"/> &lt;!-- 网页作者 --> &lt;meta name=\"author\" content=\"name, email@gmail.com\"/> &lt;!-- 搜索引擎抓取 --> &lt;meta name=\"robots\" content=\"index,follow\"/> &lt;!-- 为移动设备添加 viewport --> &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"> &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --> &lt;!-- iOS 设备 begin --> &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"> &lt;!-- 添加到主屏后的标题（iOS 6 新增） --> &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/> &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --> &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"> &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --> &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/> &lt;!-- 设置苹果工具栏颜色 --> &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/> &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --> &lt;!-- 启用360浏览器的极速模式(webkit) --> &lt;meta name=\"renderer\" content=\"webkit\"> &lt;!-- 避免IE使用兼容模式 --> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;!-- 不让百度转码 --> &lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /> &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --> &lt;meta name=\"HandheldFriendly\" content=\"true\"> &lt;!-- 微软的老式浏览器 --> &lt;meta name=\"MobileOptimized\" content=\"320\"> &lt;!-- uc强制竖屏 --> &lt;meta name=\"screen-orientation\" content=\"portrait\"> &lt;!-- QQ强制竖屏 --> &lt;meta name=\"x5-orientation\" content=\"portrait\"> &lt;!-- UC强制全屏 --> &lt;meta name=\"full-screen\" content=\"yes\"> &lt;!-- QQ强制全屏 --> &lt;meta name=\"x5-fullscreen\" content=\"true\"> &lt;!-- UC应用模式 --> &lt;meta name=\"browsermode\" content=\"application\"> &lt;!-- QQ应用模式 --> &lt;meta name=\"x5-page-mode\" content=\"app\"> &lt;!-- windows phone 点击无高光 --> &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"> &lt;!-- iOS 图标 begin --> &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/> &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --> &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/> &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --> &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/> &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --> &lt;!-- iOS 图标 end --> &lt;!-- iOS 启动画面 begin --> &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/> &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --> &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/> &lt;!-- iPad 竖屏 1536x2008（Retina） --> &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/> &lt;!-- iPad 横屏 1024x748（标准分辨率） --> &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/> &lt;!-- iPad 横屏 2048x1496（Retina） --> &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/> &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --> &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/> &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --> &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/> &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --> &lt;!-- iOS 启动画面 end --> &lt;!-- iOS 设备 end --> &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/> &lt;!-- Windows 8 磁贴颜色 --> &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/> &lt;!-- Windows 8 磁贴图标 --> &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/> &lt;!-- 添加 RSS 订阅 --> &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/> &lt;!-- 添加 favicon icon --> &lt;!-- sns 社交标签 begin --> &lt;!-- 参考微博API --> &lt;meta property=\"og:type\" content=\"类型\" /> &lt;meta property=\"og:url\" content=\"URL地址\" /> &lt;meta property=\"og:title\" content=\"标题\" /> &lt;meta property=\"og:image\" content=\"图片\" /> &lt;meta property=\"og:description\" content=\"描述\" /> &lt;!-- sns 社交标签 end --> 参考：常用的 HTML 头部标签","categories":[{"name":"html","slug":"html","permalink":"https://www.moumaobuchiyu.com/categories/html/"}],"tags":[{"name":"meta","slug":"meta","permalink":"https://www.moumaobuchiyu.com/tags/meta/"},{"name":"html","slug":"html","permalink":"https://www.moumaobuchiyu.com/tags/html/"}]},{"title":"关于Promise","slug":"关于Promise","date":"2017-03-28T03:15:50.000Z","updated":"2017-04-25T11:21:58.000Z","comments":true,"path":"2017/03/28/关于Promise/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/03/28/关于Promise/","excerpt":"","text":"前言 首先设想一个日常开发常常会遇到的需求：在多个接口异步请求数据，然后利用这些数据来进行一系列的操作。一般会这样去写： $.ajax({ url: &#39;......&#39;, success: function (data) { $.ajax({ // 要在第一个请求成功后才可以执行下一步 url: &#39;......&#39;, success: function (data) { // ...... } }); } }); 这样的写法的原理是，当执行一些异步操作时，我们需要知道操作是否已经完成，所有当执行完成的时候会返回一个回调函数，表示操作已经完成。 使用回调函数的形式理解起来并不困难，但是实际的应用当中会有以下的缺点： 1.在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的 Callback Hell。2.如果几个异步操作之间并没有前后顺序之分（例如不需要前一个请求的结果作为后一个请求的参数）时，同样需要等待上一个操作完成再实行下一个操作。 为了解决上述的问题，Promise 对象应运而生，在 EMCAScript 2015 当中已经成为标准。 什么是 Promise 一个 Promise 对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了 Promise对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。而且由于 Promise.all这样的方法存在，可以让同时执行多个操作变得简单。接下来就来简单介绍 Promise 对象。 resolve 和 reject 首先来看一段使用了 Promise 对象的代码。首先来看一段使用了 Promise 对象的代码。 function helloWorld (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(&quot;Hello World!&quot;); } else { reject(&quot;Good bye!&quot;); } }); } helloWorld(true).then(function (message) { alert(message); }, function (error) { alert(error); }); 上面的代码实现的功能非常简单，helloWord 函数接受一个参数，如果为 true 就打印 “Hello World!”，如果为 false 就打印错误的信息。helloWord 函数返回的是一个 Promise 对象。 在 Promise 对象当中有两个重要方法————resolve 和 reject。 resolve 方法可以使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。 reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 Promise 的三种状态 上面提到了 resolve 和 reject 可以改变 Promise 对象的状态，那么它究竟有哪些状态呢？ Promise 对象有三种状态： 1.Fulfilled 可以理解为成功的状态2.Rejected 可以理解为失败的状态 Pending 既不是 Fulfilld 也不是3.Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态 helloWorld 的例子中的 then 方法就是根据 Promise 对象的状态来确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject 时执行第二个函数（onRejected）。 then 和 catch then helloWorld 的例子当中利用了 then(onFulfilld, onRejected) 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下 then 方法同样可以用一个清晰的方式完成。 function printHello (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(&quot;Hello&quot;); } else { reject(&quot;Good bye!&quot;); } }); } function printWorld () { alert(&quot;World&quot;); } function printExclamation () { alert(&quot;!&quot;); } printHello(true) .then(function(message){ alert(message); }) .then(printWorld) .then(printExclamation); 上述例子通过链式调用的方式，按顺序打印出了相应的内容。then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象。另外，在 then onFulfilled 的函数当中的返回值，可以作为后续操作的参数，因此上面的例子也可以写成： printHello(true).then(function (message) { return message; }).then(function (message) { return message + &#39; World&#39;; }).then(function (message) { return message + &#39;!&#39;; }).then(function (message) { alert(message); }); catchcatch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch 的写法比一般的写法更加清晰明确。 somePromise().then(function () { return anotherPromise(); }).then(function () { return yetAnotherPromise(); }).catch(console.log.bind(console)); // &lt;-- this is badass Promise.all 和 Promise.race Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 var p1 = new Promise(function (resolve) { setTimeout(function () { resolve(&quot;Hello&quot;); }, 3000); }); var p2 = new Promise(function (resolve) { setTimeout(function () { resolve(&quot;World&quot;); }, 1000); }); Promise.all([p1, p2]).then(function (result) { console.log(result); // [&quot;Hello&quot;, &quot;World&quot;] }); 上面的例子模拟了传输两个数据需要不同的时长，虽然 p2 的速度比 p1 要快，但是 Promise.all 方法会按照数组里面的顺序将结果返回。 日常开发中经常会遇到这样的需求，在不同的接口请求数据然后拼合成自己所需的数据，通常这些接口之间没有关联（例如不需要前一个接口的数据作为后一个接口的参数），这个时候 Promise.all 方法就可以派上用场了。 还有一个和 Promise.all 相类似的方法 Promise.race，它同样接收一个数组，不同的是只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。 兼容性 在浏览器端，一些主流的浏览器都已经可以使用 Promise 对象进行开发，在 Node.js 配合 babel 也可以很方便地使用。 如果要兼容旧的浏览器，建议可以寻找一些第三方的解决方案，例如 jQuery 的 $.Deferred。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"https://www.moumaobuchiyu.com/tags/promise/"}]},{"title":"JS中的回调函数","slug":"JS中的回调函数","date":"2017-03-24T00:28:52.000Z","updated":"2017-04-25T11:22:18.000Z","comments":true,"path":"2017/03/24/JS中的回调函数/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/03/24/JS中的回调函数/","excerpt":"","text":"###关于回调函数 首先要了解，在 js 中，函数也是对象，可以赋值给变量，可以作为参数放在函数的参数列表中。比如： var doSomething = function(a,b) { return a + b; } 这段代码的意思是定义一个匿名函数，这个匿名函数除了没有名字之外，其他跟普通的函数没有什么两样。然后把匿名函数赋值给变量doSomething。接下来我们调用： console.log(doSomething(2,3));//5 回调函数，就是放在另外一个函数（如 parent）的参数列表中，作为参数传递给这个 parent，然后在 parent 函数体的某个位置执行: var doit = function(callback) { var a = 1, b = 2, c = 3; var t = callback(a,b,c); return t + 10; }; var d = doit(function(x,y,z){ return (x+y+z); }); console.log(d); 先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。 下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。 上述代码的执行过程是： 调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。 传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。 但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用，甚至在这里强烈推荐使用。 因此，回调本质上是一种设计模式，并且jQuery(包括其他框架)的设计原则遵循了这个模式。 在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。 //基本方式 function doSomething(callback) { // … // Call the callback callback(&#39;stuff&#39;, &#39;goes&#39;, &#39;here&#39;); } function foo(a, b, c) { // I&#39;m the callback alert(a + &quot; &quot; + b + &quot; &quot; + c); } doSomething(foo); //匿名函数的形式 function dosomething(damsg, callback){ alert(damsg); if(typeof callback == &quot;function&quot;) callback(); } dosomething(&quot;回调函数&quot;, function(){ alert(&quot;和 jQuery 的 callbacks 形式一样!&quot;); }); 所以callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。 回调什么时候执行 回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。 回调函数的使用场合 资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。 DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。 setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现 链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。 回调函数的传递 $.get(&#39;myhtmlpage.html&#39;, myCallBack);//这是对的 $.get(&#39;myhtmlpage.html&#39;, myCallBack(&#39;foo&#39;, &#39;bar&#39;));//这是错的，那么要带参数呢？ $.get(&#39;myhtmlpage.html&#39;, function(){//带参数的使用函数表达式 myCallBack(&#39;foo&#39;, &#39;bar&#39;); }); 另外，最好保证回调存在且必须是函数引用或者函数表达式： (callback &amp;&amp; typeof(callback) ===“function”) &amp;&amp; callback(); ###回调函数使用实例 //使用call方法 function Thing(name) { this.name = name; } Thing.prototype.doSomething = function(callback) { // Call our callback, but using our own instance as the context callback.call(this); } function foo() { alert(this.name); } var t = new Thing(&#39;Joe&#39;); t.doSomething(foo); // Alerts &quot;Joe&quot; via `foo` //传参数 function Thing(name) { this.name = name; } Thing.prototype.doSomething = function(callback, salutation) { // Call our callback, but using our own instance as the context callback.call(this, salutation); } function foo(salutation) { alert(salutation + &quot; &quot; + this.name); } var t = new Thing(&#39;Joe&#39;); t.doSomething(foo, &#39;Hi&#39;); // Alerts &quot;Hi Joe&quot; via `foo` //使用apply传参 function Thing(name) { this.name = name; } Thing.prototype.doSomething = function(callback) { // Call our callback, but using our own instance as the context callback.apply(this, [&#39;Hi&#39;, 3, 2, 1]); } function foo(salutation, three, two, one) { alert(salutation + &quot; &quot; + this.name + &quot; – &quot; + three + &quot; &quot; + two + &quot; &quot; + one); } var t = new Thing(&#39;Joe&#39;); t.doSomething(foo); // Alerts &quot;Hi Joe – 3 2 1&quot; via `foo` //假如提供的数据源是一整数,为某学生的分数,当num&lt;=0,由底层处理,当n&gt;0时由高层处理. //将下面这个函数拷贝下来存盘为1.js function f(num,callback){ if(num&lt;0) { alert(&quot;调用低层函数处理!&quot;); alert(&quot;分数不能为负,输入错误!&quot;); }else if(num==0){ alert(&quot;调用低层函数处理!&quot;); alert(&quot;该学生可能未参加考试！&quot;); }else{ alert(&quot;调用高层函数处理!&quot;); callback(); } } //将下面这个test.html文件存盘与1.js在一个目录下： &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt; &lt;script src=&quot;1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test(){ var p=document.getElementById(&quot;pp&quot;); pp.innerText=&quot;&quot;; var num=document.getElementById(&quot;score&quot;).value; f(num,function(){ //匿名高层处理函数 if(num&lt;60) alert(&quot;未及格！&quot;); else if(num&lt;=90) alert(&quot;该生成绩优良！&quot;); else alert(&quot;该生成绩优秀!&quot;); }) pp.innerText=&quot;by since1978 qq558064!&quot; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 回调函数示例:当学生成绩score&lt;=0分时候，由底层处理；当score&gt;0时，由高层处理。 &lt;/p&gt; 请输入学生成绩&lt;input type=&quot;text&quot; id=&quot;score&quot;&gt; &lt;input type=&quot;button&quot; onClick=&quot;test()&quot; value=&quot; 看看结果&quot;&gt; &lt;p id=&quot;pp&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; //node.js中出现的回调函数 app.use(function(req, res, next) { var err = new Error(&#39;Not Found&#39;); err.status = 404; next(err); }); ###小结回调函数是实现js异步编程的四种方法之一，但并不推荐用此方法： 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 不过正如上文所说，回调函数不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。 在javascript中回调函数非常重要，它们几乎无处不在","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/tags/javascript/"},{"name":"回调函数","slug":"回调函数","permalink":"https://www.moumaobuchiyu.com/tags/回调函数/"}]},{"title":"什么是动态HTML？-DHTML","slug":"什么是动态HTML？-DHTML","date":"2017-03-23T14:07:50.000Z","updated":"2017-04-25T11:22:12.000Z","comments":true,"path":"2017/03/23/什么是动态HTML？-DHTML/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/03/23/什么是动态HTML？-DHTML/","excerpt":"","text":"DHTML是Dynamic HTML的简称，中文译为“动态超文本标记语言”，主要用途是提**TML页面的交互性和可操作性。它是建立在传统HTML基础上的客户端动态技术，是一种技术的总称，它通过HTML、VBScript、JavaScript邮和CSS等语言、技术使网页能够具有动态交互功能。虽然HTML语言可以制作出具有复杂格式的网页，但这样制作出来的网页只包含静态内容。凡是网页上有任何信息需要更新，浏览器就必须从服务器上重新下载整个网页，因而给网络造成极大的负担。它是建立在传统HTML基础上的客户端动态技术。 DHTML实现了网页从Web服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。这是近年来网络飞速发展进程中员振奋人心也最具实用性的技术之一。DHTML是一种通过各种技术的综合发展而来的概念，这些技术包括JavaScript、VBScript、DOM(Document Object Mode，文档对象模型)、Layers和CSS(Cascading Style Sheets，层又叠样式表)等。目前IE4．0以上的大多数浏览器都加入了对DHTML的支持，主要包括以下内容： ①动态内容(Dynamic Content)：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。​ ②动态排版样式(Dynamic StyleSheets)：W3C的CSS样式表提供了设定HTML标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。","categories":[{"name":"html","slug":"html","permalink":"https://www.moumaobuchiyu.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://www.moumaobuchiyu.com/tags/html/"},{"name":"dhtml","slug":"dhtml","permalink":"https://www.moumaobuchiyu.com/tags/dhtml/"}]},{"title":"JS中this的指向","slug":"JS中this的指向","date":"2017-03-22T06:14:42.000Z","updated":"2017-04-25T11:22:24.000Z","comments":true,"path":"2017/03/22/JS中this的指向/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/03/22/JS中this的指向/","excerpt":"this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如: function test(){ this.x = 1; } 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 下面分四种情况，详细讨论this的用法。","text":"this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如: function test(){ this.x = 1; } 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 下面分四种情况，详细讨论this的用法。 情况一：纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象。 请看下面这段代码，它的运行结果是1。 function test(){ this.x = 1; alert(this.x); } test(); // 1 为了证明this就是全局对象，我对代码做一些改变： var x = 1; function test(){ alert(this.x); } test(); // 1 运行结果还是1。再变一下： var x = 1; function test(){ this.x = 0; } test(); alert(x); //0 情况二：作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象。 function test(){ alert(this.x); } var o = {}; o.x = 1; o.m = test; o.m(); // 1 情况三 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 function test(){ this.x = 1; } var o = new test(); alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变： var x = 2; function test(){ this.x = 1; } var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 情况四 apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数 var x = 0; function test(){ alert(this.x); } var o={}; o.x = 1; o.m = test; o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为 : o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/tags/javascript/"},{"name":"this","slug":"this","permalink":"https://www.moumaobuchiyu.com/tags/this/"}]},{"title":" js中Math.random()生成指定范围数值的随机数","slug":"js中Math-random-生成指定范围数值的随机数","date":"2017-03-20T15:43:56.000Z","updated":"2017-05-10T11:18:41.000Z","comments":true,"path":"2017/03/20/js中Math-random-生成指定范围数值的随机数/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/03/20/js中Math-random-生成指定范围数值的随机数/","excerpt":"","text":"定义和用法 random() 方法可返回介于 0 ~ 1 之间的一个随机数。 语法 Math.random() 返回值 0.0 ~ 1.0 之间的一个伪随机数。 实例 在本例中，我们将取得介于 0 到 1 之间的一个随机数： &lt;script type=\"text/javascript\"> document.write(Math.random()); &lt;/script> // 输出： 0.15246391076246546 关于如何生成指定范围值的随机数？ 利用 parseInt()、Math.floor() 或者 Math.ceil()进行四舍五入处理 我们看到，直接使用Math.random()方法，生成的是一个小于1的数，所以： Math.random()*5 得到的结果是一个小于5的随机数。而我们通常希望得到的是0-5之间的整数，所以我们需要对得到的结果四舍五入处理一下，从而得到我们期望的整数。parseInt()、Math.floor()和Math.ceil()都可以起到四舍五入的作用。 var randomNum = Math.random()*5; alert(randomNum); // 2.9045290905811183 alert(parseInt(randomNum,10)); // 2 alert(Math.floor(randomNum)); // 2 alert(Math.ceil(randomNum)); // 3 由测试的代码我们可以看到，parseInt()和Math.floor()的效果是一样的，都是向下取整数部分。所以parseInt(Math.random()*5,10)和Math.floor(Math.random()*5)都是生成的0-4之间的随机数，Math.ceil(Math.random()*5)则是生成的1-5之间的随机数。 生成指定范围数值随机数 如果你希望生成1到任意值的随机数，公式就是这样的： // max - 期望的最大值 parseInt(Math.random()*max,10)+1; Math.floor(Math.random()*max)+1; Math.ceil(Math.random()*max); 如果你希望生成0到任意值的随机数，公式就是这样的： // max - 期望的最大值 parseInt(Math.random()*(max+1),10); Math.floor(Math.random()*(max+1)); 如果你希望生成任意值到任意值的随机数，公式就是这样的： // max - 期望的最大值 // min - 期望的最小值 parseInt(Math.random()*(max-min+1)+min,10); Math.floor(Math.random()*(max-min+1)+min);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/tags/javascript/"}]},{"title":"Node.js部署到阿里云服务器","slug":"nodejs部署到阿里云全过程","date":"2017-03-16T07:26:51.000Z","updated":"2017-04-25T11:21:39.000Z","comments":true,"path":"2017/03/16/nodejs部署到阿里云全过程/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/03/16/nodejs部署到阿里云全过程/","excerpt":"","text":"整个部署过程学到了不少东西，记录一下。 参考了以下文章： http://itbilu.com/other/relate/NJ2TJohl.htmlhttps://segmentfault.com/a/1190000004051670http://borninsummer.com/2015/06/17/notes-on-developing-nodejs-webapp/https://bbs.aliyun.com/read/146189.html 1. 到阿里云购买云服务器 ECS 。https://www.aliyun.com/product/ecs如果是在校学生，在淘宝有实名认证，且在学信网有注册，可以试试抢学生的首月优惠套餐。https://www.aliyun.com/act/aliyun/campus.html作为一个穷逼+不熟悉服务器配置的菜鸟。选了最便宜的套餐：CPU： 1核 / 内存： 1024 MB / 带宽：1Mbps / 操作系统： CentOS 7.0购买环节会设置 ssh 登陆密码，记下密码。登陆到阿里云，查看购买的实例。注意公网 IP，下一步会用到2. 登陆服务器sudo ssh 你的服务器ip地址 关于 ssh 登陆，具体可以看http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html 这篇文章。 提示输入mac的密码，提示输入服务器密码。输入后连接成功并显示服务器信息，如下： 登陆服务器后。这里对于我这个 Linux 菜鸟有个大坑………就是 Linux 系统常见的目录结构和文件放置区域。使用 root 用户身份登陆后，会直接进入到下图 红色箭头标出的 root 目录下。先 cd .. 跳转到上一层, 再 ls -a ，就可以看到类似下图的目录结构了。 3.安装 node 和 mongodb node – 编译后二进制文件应在/usr/local/bin/node 下 mongodb –安装在/usr/local/mongodb 下 下面就一步一步来，首先升级CentOS yum -y update 升级后，跳转到 /usr/local/src , 这个文件夹通常用来存放软件源代码 cd /usr/local/src 下载 nodejs 代码，也可以使用scp命令直接上传，因为下载实在太慢了。 wget http://nodejs.org/dist/v0.12.5/node-v0.12.5.tar.gz //注*根据最新版本号为准 解压 tar -xzvf node-v0.12.5.tar.gz 进入解压后的文件夹 cd node-v0.12.5 执行配置脚本来进行编译预处理 ./configure 编译源代码 make //注*这个时间可能会很久 当编译完成后，需要使之在系统范围内可用, 编译后的二进制文件将被放置到系统路径，默认情况下，Node二进制文件应该放在/user/local/bin/node文件夹下 make install 安装 express 和 forever，这两个模块都推荐 global 安装 npm -g install express forever 建立超级链接, 不然 sudo node 时会报 “command not found” sudo ln -s /usr/local/bin/node /usr/bin/node sudo ln -s /usr/local/lib/node /usr/lib/node sudo ln -s /usr/local/bin/npm /usr/bin/npm sudo ln -s /usr/local/bin/node-waf /usr/bin/node-waf sudo ln -s /usr/local/bin/forever /usr/bin/forever Nodejs到这里就基本安装完成了。 下面来安装mongodb 软件安装位置：/usr/local/mongodb数据存放位置：/var/mongodb/data日志存放位置：/var/mongodb/logs 首先下载安装包 cd /usr/local wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.4.9.tgz 解压安装包，重命名文件夹为mongodb tar zxvf mongodb-linux-x86_64-2.6.0.tgz mv mongodb-linux-x86_64-2.6.0 mongodb 创建数据和日志存放目录 mkdir /var/mongodb mkdir /var/mongodb/data mkdir /var/mongodb/logs 打开rc.local文件，添加CentOS开机启动项： vim /etc/rc.d/rc.local 将mongodb启动命令追加到本文件中，让mongodb开机自启动： /usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork 关闭 vim 后，直接手动启动mongodb /usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork 看到类似的信息，说明已启动成功。我在这里发了个傻，以为26308是port号，导致后面设置port时折腾了好久。其实这里的 forked process 和 port 号是两个东西， 这个是程序本身在Server上的进程。 forked process: 26308 启动mongo shell cd /usr/local/mongodb/bin/ ./mongo 在 mongo shell 中创建管理员及数据库 use admin //admin 数据库 db.createUser({ user: &quot;用户名&quot;, pwd:&quot;登陆密码&quot;, roles:[&quot;userAdminAnyDatabase&quot;] //超级管理员 }) use databaseFoo //nodeapp 要连接的数据库 db.createUser({ user: &quot;用户名&quot;, pwd:&quot;登陆密码&quot;, roles:[&quot;readWrite&quot;] //读写权限 }) 到这里 mongodb 基本已经安装设置完成了。具体数据的迁移导入可自行研究。 4.配置及启动node app 我们把 nodeapp 的程序放在 /home 下 cd /home 我使用 http://git.oschina.net/ 管理代码。它的私有库是免费的。基本操作和 github 一样。复制代码： git clone https://git.oschina.net/xxxxxxx/nodeapp.git //你的repo地址 注*同时可以使用图形化程序进行上传如File Zilla进入 nodeapp 文件夹 cd nodeapp （若后续代码变更，提交到 git repo 后直接git pull即可部署代码）安装nodeapp的所有依赖 npm install 在启动文件 ( 我的是 app.js ) 中设置数据库连接 vim app.js 数据库连接类似下面的格式，由于数据库安装在同一服务器，因此 host 为127.0.0.1： var dbUrl = &#39;mongodb://用户名:登陆密码@127.0.0.1/databaseFoo&#39;; mongoose.connect(dbUrl) 这里要注意，如果直接 npm start 或 node app.js 启动，则一旦退出 ssh 远程登陆，nodeapp 就会停止运行。因此我们使用 forever 启动 nodeapp。 NODE_ENV=production forever start app.js 如今可以使用PM2启动程序，步骤如下：使用它要先安装它，用root账号和全局模式安装一下：npm install -g pm2用它来启动程序（在当前目录下可以直接启动）pm2 start app.js --name uops 在蹚过无数坑后，项目部署成功。用浏览器打开 公网IP:端口号 即可看到 nodeapp 的首页","categories":[{"name":"node.js","slug":"node-js","permalink":"https://www.moumaobuchiyu.com/categories/node-js/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.moumaobuchiyu.com/tags/javascript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.moumaobuchiyu.com/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-28T03:15:50.000Z","updated":"2017-05-08T07:08:28.000Z","comments":true,"path":"2017/01/28/hello-world/","link":"","permalink":"https://www.moumaobuchiyu.com/2017/01/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"日常","slug":"日常","permalink":"https://www.moumaobuchiyu.com/categories/日常/"}],"tags":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://www.moumaobuchiyu.com/tags/HelloWorld/"}]}]}