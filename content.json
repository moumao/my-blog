{"meta":{"title":"某猫のBlog","subtitle":null,"description":null,"author":"moumao","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-03-20T14:58:10.000Z","updated":"2017-03-20T14:58:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"你可以叫我某猫","date":"2017-03-20T12:57:33.000Z","updated":"2017-03-22T16:24:34.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"腹有诗书气自华 算是我很喜欢的一句话了吧 总是理想成为这样的人 关于我 在主站的about me中都有说过 喜欢前端，喜欢摄影，喜欢晒妻 喜欢所有美貌的一切 大抵是个颜控吧哈哈 所以也算半个果粉吧 也是别人嘴里的肥宅？？？ 今年一定要减肥 hexo的博客主题暂时用Material吧 在此谢谢vio喵的作品 关于为什么用github搭hexo 因为我的服务器装Nginx的时候炸了 就懒得再弄 其实对服务器的东西也不是很懂 打算写完自己的主题再放到服务器上 自己的主题还在开发中 主站是用node搭建的 不过很简单 也不知道写些什么上去 晒妻的照片先放到LOFTER上 之后会再做个相册的 就这些吧。 希望今年能在杭州找个说得过去的工作 感觉越学坑越多"}],"posts":[{"title":"meta标签总结","slug":"meta标签总结","date":"2017-04-05T03:28:28.000Z","updated":"2017-04-05T09:36:33.000Z","comments":true,"path":"2017/04/05/meta标签总结/","link":"","permalink":"http://yoursite.com/2017/04/05/meta标签总结/","excerpt":"","text":"定义 meta 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 以上是w3c上的解释。元信息，是用来描述数据的数据，也就是用来描述当前页面的一些信息。例如：定义页面的说明，关键字、作者等等。 包含的属性1.name属性 name 属性提供了名称/值对中的名称（而后面要说的content属性则是该名称对应的值）。假如我们把页面想象成一个我们生活中的实物的话，拿个人简历来作类比，诸如姓名、性别、籍贯、技能、项目经验等等这些都可以看做是个人简历的name属性，content属性相当于这些名称对应的值。 1&lt;meta name=&quot;名称&quot; content=&quot;具体的描述&quot;&gt; 2.content属性 content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。content 属性始终要和 name 属性或 http-equiv 属性一起使用。1&lt;meta name=&quot;名称&quot; content=&quot;具体的描述&quot;&gt; 3.http-equiv属性 equiv是equivalent的简写，是相等的，等价物的意思。不难理解，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 1&lt;meta http-equiv=&quot;名称&quot; content=&quot;具体的描述&quot;&gt; 常用的标签使用 HTML5 doctype，不区分大小写。 1&lt;!DOCTYPE html&gt; //使用 HTML5 doctype，不区分大小写 声明文档使用的字符编码 12&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; //旧的HTML，不推荐&lt;meta charset=&quot;utf-8&quot;&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8 renderer(双核浏览器渲染方式) 说明：renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。 123&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; //默认webkit内核&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式 X-UA-Compatible(浏览器采取何种版本渲染当前页面) 说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。） 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; //指定IE和Chrome使用最新版本渲染当前页面 refresh(自动刷新并指向某页面) 说明：网页将在设定的时间内，自动刷新并调向设定的网址。 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=http://www.w3school.com.cn&quot; /&gt; //5秒后重定向到w3c官网 SEO 优化 页面描述 每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签 1&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;&gt; &lt;!-- 页面描述 --&gt; 页面关键词 1&lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;!-- 页面关键词 --&gt; 定义页面标题 1&lt;title&gt;标题&lt;/title&gt; 定义网页作者 1&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;&gt; &lt;!-- 网页作者 --&gt; 定义网页搜索引擎索引方式，robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 1&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; &lt;!-- 搜索引擎抓取 --&gt; 为移动设备添加 viewport 1&lt;meta name =&quot;viewport&quot; content =&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; width=device-width 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 content 参数： width viewport 宽度(数值/device-width) height viewport高度(数值/device-height) initial-scale 初始缩放比例 maximum-scale 最大缩放比例minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) minimal-ui iOS7.1 beta 2 中新增属性（注意：iOS8 中已经删除），可以在页面加载时最小化上下状态栏。这是一个布尔值，可以直接这样写： 以及一些其他的标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!-- 声明文档使用的字符编码 --&gt;&lt;meta charset=&apos;utf-8&apos;&gt;&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;&lt;!-- 页面描述 --&gt;&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;&lt;!-- 页面关键词 --&gt;&lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;&lt;!-- 网页作者 --&gt;&lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;&lt;!-- 搜索引擎抓取 --&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;!-- 为移动设备添加 viewport --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;&lt;!-- iOS 设备 begin --&gt;&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;&lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt;&lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;&lt;!-- iOS 图标 begin --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;&lt;!-- iOS 图标 end --&gt;&lt;!-- iOS 启动画面 begin --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;&lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;&lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;&lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;&lt;!-- iPad 横屏 2048x1496（Retina） --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;/splash-screen-320x480.png&quot;/&gt;&lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x960&quot; href=&quot;/splash-screen-640x960.png&quot;/&gt;&lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x1136&quot; href=&quot;/splash-screen-640x1136.png&quot;/&gt;&lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;&lt;!-- iOS 启动画面 end --&gt;&lt;!-- iOS 设备 end --&gt;&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#000&quot;/&gt;&lt;!-- Windows 8 磁贴颜色 --&gt;&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;icon.png&quot;/&gt;&lt;!-- Windows 8 磁贴图标 --&gt;&lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;&lt;!-- 添加 RSS 订阅 --&gt;&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt;&lt;!-- 添加 favicon icon --&gt;&lt;!-- sns 社交标签 begin --&gt;&lt;!-- 参考微博API --&gt;&lt;meta property=&quot;og:type&quot; content=&quot;类型&quot; /&gt;&lt;meta property=&quot;og:url&quot; content=&quot;URL地址&quot; /&gt;&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;&lt;meta property=&quot;og:description&quot; content=&quot;描述&quot; /&gt;&lt;!-- sns 社交标签 end --&gt; 参考：常用的 HTML 头部标签","categories":[],"tags":[{"name":"meta H5","slug":"meta-H5","permalink":"http://yoursite.com/tags/meta-H5/"}]},{"title":"关于Promise","slug":"关于Promise","date":"2017-03-28T03:15:50.000Z","updated":"2017-03-28T05:28:12.000Z","comments":true,"path":"2017/03/28/关于Promise/","link":"","permalink":"http://yoursite.com/2017/03/28/关于Promise/","excerpt":"","text":"前言 首先设想一个日常开发常常会遇到的需求：在多个接口异步请求数据，然后利用这些数据来进行一系列的操作。一般会这样去写： 1234567891011$.ajax(&#123;url: &apos;......&apos;,success: function (data) &#123;$.ajax(&#123;// 要在第一个请求成功后才可以执行下一步url: &apos;......&apos;,success: function (data) &#123;// ......&#125;&#125;);&#125; &#125;); 这样的写法的原理是，当执行一些异步操作时，我们需要知道操作是否已经完成，所有当执行完成的时候会返回一个回调函数，表示操作已经完成。 使用回调函数的形式理解起来并不困难，但是实际的应用当中会有以下的缺点： 1.在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的 Callback Hell。2.如果几个异步操作之间并没有前后顺序之分（例如不需要前一个请求的结果作为后一个请求的参数）时，同样需要等待上一个操作完成再实行下一个操作。 为了解决上述的问题，Promise 对象应运而生，在 EMCAScript 2015 当中已经成为标准。 什么是 Promise 一个 Promise 对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了 Promise对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。而且由于 Promise.all这样的方法存在，可以让同时执行多个操作变得简单。接下来就来简单介绍 Promise 对象。 resolve 和 reject 首先来看一段使用了 Promise 对象的代码。首先来看一段使用了 Promise 对象的代码。 123456789101112131415function helloWorld (ready) &#123;return new Promise(function (resolve, reject) &#123;if (ready) &#123;resolve(&quot;Hello World!&quot;);&#125; else &#123;reject(&quot;Good bye!&quot;);&#125;&#125;);&#125;helloWorld(true).then(function (message) &#123;alert(message);&#125;, function (error) &#123;alert(error);&#125;); 上面的代码实现的功能非常简单，helloWord 函数接受一个参数，如果为 true 就打印 “Hello World!”，如果为 false 就打印错误的信息。helloWord 函数返回的是一个 Promise 对象。 在 Promise 对象当中有两个重要方法————resolve 和 reject。 resolve 方法可以使 Promise 对象的状态改变成成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。 reject 方法则是将 Promise 对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 Promise 的三种状态 上面提到了 resolve 和 reject 可以改变 Promise 对象的状态，那么它究竟有哪些状态呢？ Promise 对象有三种状态： 1.Fulfilled 可以理解为成功的状态2.Rejected 可以理解为失败的状态 Pending 既不是 Fulfilld 也不是3.Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态 helloWorld 的例子中的 then 方法就是根据 Promise 对象的状态来确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject 时执行第二个函数（onRejected）。 then 和 catch then helloWorld 的例子当中利用了 then(onFulfilld, onRejected) 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下 then 方法同样可以用一个清晰的方式完成。 123456789101112131415161718192021222324function printHello (ready) &#123;return new Promise(function (resolve, reject) &#123;if (ready) &#123;resolve(&quot;Hello&quot;);&#125; else &#123;reject(&quot;Good bye!&quot;);&#125;&#125;);&#125;function printWorld () &#123;alert(&quot;World&quot;);&#125;function printExclamation () &#123;alert(&quot;!&quot;);&#125;printHello(true).then(function(message)&#123;alert(message);&#125;).then(printWorld).then(printExclamation); 上述例子通过链式调用的方式，按顺序打印出了相应的内容。then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象。另外，在 then onFulfilled 的函数当中的返回值，可以作为后续操作的参数，因此上面的例子也可以写成： 123456789printHello(true).then(function (message) &#123;return message;&#125;).then(function (message) &#123;return message + &apos; World&apos;;&#125;).then(function (message) &#123;return message + &apos;!&apos;;&#125;).then(function (message) &#123;alert(message);&#125;); catchcatch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch 的写法比一般的写法更加清晰明确。 12345somePromise().then(function () &#123;return anotherPromise();&#125;).then(function () &#123;return yetAnotherPromise();&#125;).catch(console.log.bind(console)); // &lt;-- this is badass Promise.all 和 Promise.race Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 123456789101112131415var p1 = new Promise(function (resolve) &#123;setTimeout(function () &#123;resolve(&quot;Hello&quot;);&#125;, 3000);&#125;);var p2 = new Promise(function (resolve) &#123;setTimeout(function () &#123;resolve(&quot;World&quot;);&#125;, 1000);&#125;);Promise.all([p1, p2]).then(function (result) &#123;console.log(result); // [&quot;Hello&quot;, &quot;World&quot;]&#125;); 上面的例子模拟了传输两个数据需要不同的时长，虽然 p2 的速度比 p1 要快，但是 Promise.all 方法会按照数组里面的顺序将结果返回。 日常开发中经常会遇到这样的需求，在不同的接口请求数据然后拼合成自己所需的数据，通常这些接口之间没有关联（例如不需要前一个接口的数据作为后一个接口的参数），这个时候 Promise.all 方法就可以派上用场了。 还有一个和 Promise.all 相类似的方法 Promise.race，它同样接收一个数组，不同的是只要该数组中的 Promise 对象的状态发生变化（无论是 resolve 还是 reject）该方法都会返回。 兼容性 在浏览器端，一些主流的浏览器都已经可以使用 Promise 对象进行开发，在 Node.js 配合 babel 也可以很方便地使用。 如果要兼容旧的浏览器，建议可以寻找一些第三方的解决方案，例如 jQuery 的 $.Deferred。","categories":[],"tags":[{"name":"js promise","slug":"js-promise","permalink":"http://yoursite.com/tags/js-promise/"}]},{"title":"JS中的回调函数","slug":"JS中的回调函数","date":"2017-03-24T00:28:52.000Z","updated":"2017-03-24T01:14:46.000Z","comments":true,"path":"2017/03/24/JS中的回调函数/","link":"","permalink":"http://yoursite.com/2017/03/24/JS中的回调函数/","excerpt":"","text":"###关于回调函数 首先要了解，在 js 中，函数也是对象，可以赋值给变量，可以作为参数放在函数的参数列表中。比如： 1234var doSomething = function(a,b)&#123;return a + b;&#125; 这段代码的意思是定义一个匿名函数，这个匿名函数除了没有名字之外，其他跟普通的函数没有什么两样。然后把匿名函数赋值给变量doSomething。接下来我们调用： 1console.log(doSomething(2,3));//5 回调函数，就是放在另外一个函数（如 parent）的参数列表中，作为参数传递给这个 parent，然后在 parent 函数体的某个位置执行: 123456789101112var doit = function(callback)&#123;var a = 1,b = 2,c = 3;var t = callback(a,b,c);return t + 10;&#125;;var d = doit(function(x,y,z)&#123;return (x+y+z);&#125;);console.log(d); 先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。 下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。 上述代码的执行过程是： 调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。 传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。 但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用，甚至在这里强烈推荐使用。 因此，回调本质上是一种设计模式，并且jQuery(包括其他框架)的设计原则遵循了这个模式。 在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。 1234567891011//基本方式function doSomething(callback) &#123;// … // Call the callbackcallback(&apos;stuff&apos;, &apos;goes&apos;, &apos;here&apos;);&#125; function foo(a, b, c) &#123;// I&apos;m the callbackalert(a + &quot; &quot; + b + &quot; &quot; + c);&#125; doSomething(foo); 123456789//匿名函数的形式function dosomething(damsg, callback)&#123;alert(damsg);if(typeof callback == &quot;function&quot;) callback();&#125; dosomething(&quot;回调函数&quot;, function()&#123;alert(&quot;和 jQuery 的 callbacks 形式一样!&quot;);&#125;); 所以callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。 回调什么时候执行 回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。 回调函数的使用场合 资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。 DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。 setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现 链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。 回调函数的传递 12345$.get(&apos;myhtmlpage.html&apos;, myCallBack);//这是对的$.get(&apos;myhtmlpage.html&apos;, myCallBack(&apos;foo&apos;, &apos;bar&apos;));//这是错的，那么要带参数呢？$.get(&apos;myhtmlpage.html&apos;, function()&#123;//带参数的使用函数表达式myCallBack(&apos;foo&apos;, &apos;bar&apos;);&#125;); 另外，最好保证回调存在且必须是函数引用或者函数表达式： (callback &amp;&amp; typeof(callback) ===“function”) &amp;&amp; callback(); ###回调函数使用实例 123456789101112131415//使用call方法function Thing(name) &#123;this.name = name;&#125;Thing.prototype.doSomething = function(callback) &#123;// Call our callback, but using our own instance as the contextcallback.call(this);&#125;function foo() &#123;alert(this.name);&#125;var t = new Thing(&apos;Joe&apos;);t.doSomething(foo); // Alerts &quot;Joe&quot; via `foo` 12345678910111213//传参数function Thing(name) &#123;this.name = name;&#125;Thing.prototype.doSomething = function(callback, salutation) &#123;// Call our callback, but using our own instance as the contextcallback.call(this, salutation);&#125; function foo(salutation) &#123;alert(salutation + &quot; &quot; + this.name);&#125; var t = new Thing(&apos;Joe&apos;);t.doSomething(foo, &apos;Hi&apos;); // Alerts &quot;Hi Joe&quot; via `foo` 12345678910111213//使用apply传参function Thing(name) &#123;this.name = name;&#125;Thing.prototype.doSomething = function(callback) &#123;// Call our callback, but using our own instance as the contextcallback.apply(this, [&apos;Hi&apos;, 3, 2, 1]);&#125; function foo(salutation, three, two, one) &#123;alert(salutation + &quot; &quot; + this.name + &quot; – &quot; + three + &quot; &quot; + two + &quot; &quot; + one);&#125; var t = new Thing(&apos;Joe&apos;);t.doSomething(foo); // Alerts &quot;Hi Joe – 3 2 1&quot; via `foo` 1234567891011121314//假如提供的数据源是一整数,为某学生的分数,当num&lt;=0,由底层处理,当n&gt;0时由高层处理.//将下面这个函数拷贝下来存盘为1.jsfunction f(num,callback)&#123;if(num&lt;0) &#123; alert(&quot;调用低层函数处理!&quot;);alert(&quot;分数不能为负,输入错误!&quot;); &#125;else if(num==0)&#123;alert(&quot;调用低层函数处理!&quot;);alert(&quot;该学生可能未参加考试！&quot;);&#125;else&#123;alert(&quot;调用高层函数处理!&quot;);callback();&#125;&#125; 12345678910111213141516171819202122232425262728293031//将下面这个test.html文件存盘与1.js在一个目录下：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;&lt;script src=&quot;1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;function test()&#123;var p=document.getElementById(&quot;pp&quot;);pp.innerText=&quot;&quot;;var num=document.getElementById(&quot;score&quot;).value;f(num,function()&#123; //匿名高层处理函数if(num&lt;60) alert(&quot;未及格！&quot;);else if(num&lt;=90) alert(&quot;该生成绩优良！&quot;);else alert(&quot;该生成绩优秀!&quot;); &#125;)pp.innerText=&quot;by since1978 qq558064!&quot;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;回调函数示例:当学生成绩score&lt;=0分时候，由底层处理；当score&gt;0时，由高层处理。&lt;/p&gt;请输入学生成绩&lt;input type=&quot;text&quot; id=&quot;score&quot;&gt; &lt;input type=&quot;button&quot; onClick=&quot;test()&quot; value=&quot; 看看结果&quot;&gt;&lt;p id=&quot;pp&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456//node.js中出现的回调函数app.use(function(req, res, next) &#123;var err = new Error(&apos;Not Found&apos;);err.status = 404;next(err);&#125;); ###小结回调函数是实现js异步编程的四种方法之一，但并不推荐用此方法： 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 不过正如上文所说，回调函数不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。 在javascript中回调函数非常重要，它们几乎无处不在","categories":[],"tags":[{"name":"js 回调函数","slug":"js-回调函数","permalink":"http://yoursite.com/tags/js-回调函数/"}]},{"title":"什么是动态HTML？-DHTML","slug":"什么是动态HTML？-DHTML","date":"2017-03-23T14:07:50.000Z","updated":"2017-03-24T01:14:39.000Z","comments":true,"path":"2017/03/23/什么是动态HTML？-DHTML/","link":"","permalink":"http://yoursite.com/2017/03/23/什么是动态HTML？-DHTML/","excerpt":"","text":"DHTML是Dynamic HTML的简称，中文译为“动态超文本标记语言”，主要用途是提**TML页面的交互性和可操作性。它是建立在传统HTML基础上的客户端动态技术，是一种技术的总称，它通过HTML、VBScript、JavaScript邮和CSS等语言、技术使网页能够具有动态交互功能。虽然HTML语言可以制作出具有复杂格式的网页，但这样制作出来的网页只包含静态内容。凡是网页上有任何信息需要更新，浏览器就必须从服务器上重新下载整个网页，因而给网络造成极大的负担。它是建立在传统HTML基础上的客户端动态技术。 DHTML实现了网页从Web服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。这是近年来网络飞速发展进程中员振奋人心也最具实用性的技术之一。DHTML是一种通过各种技术的综合发展而来的概念，这些技术包括JavaScript、VBScript、DOM(Document Object Mode，文档对象模型)、Layers和CSS(Cascading Style Sheets，层又叠样式表)等。目前IE4．0以上的大多数浏览器都加入了对DHTML的支持，主要包括以下内容： ①动态内容(Dynamic Content)：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。​ ②动态排版样式(Dynamic StyleSheets)：W3C的CSS样式表提供了设定HTML标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。","categories":[],"tags":[{"name":"HTML DHTML","slug":"HTML-DHTML","permalink":"http://yoursite.com/tags/HTML-DHTML/"}]},{"title":"JS中this的指向","slug":"JS中this的指向","date":"2017-03-22T06:14:42.000Z","updated":"2017-03-22T06:19:36.000Z","comments":true,"path":"2017/03/22/JS中this的指向/","link":"","permalink":"http://yoursite.com/2017/03/22/JS中this的指向/","excerpt":"","text":"this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如: 12345function test()&#123; this.x = 1; &#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 下面分四种情况，详细讨论this的用法。 情况一：纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象。 请看下面这段代码，它的运行结果是1。 123456789function test()&#123; this.x = 1; alert(this.x); &#125; test(); // 1 为了证明this就是全局对象，我对代码做一些改变： 123456789var x = 1; function test()&#123; alert(this.x); &#125; test(); // 1 运行结果还是1。再变一下： 1234567891011var x = 1; function test()&#123; this.x = 0; &#125; test(); alert(x); //0 情况二：作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象。 12345678910111213function test()&#123; alert(this.x); &#125; var o = &#123;&#125;; o.x = 1; o.m = test; o.m(); // 1 情况三 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 123456789function test()&#123; this.x = 1; &#125; var o = new test(); alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变： 1234567891011var x = 2; function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 情况四 apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数 123456789101112131415var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为 : 1o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":" js中Math.random()生成指定范围数值的随机数","slug":"js中Math-random-生成指定范围数值的随机数","date":"2017-03-20T15:43:56.000Z","updated":"2017-03-22T06:24:58.000Z","comments":true,"path":"2017/03/20/js中Math-random-生成指定范围数值的随机数/","link":"","permalink":"http://yoursite.com/2017/03/20/js中Math-random-生成指定范围数值的随机数/","excerpt":"","text":"定义和用法 random() 方法可返回介于 0 ~ 1 之间的一个随机数。 语法 Math.random() 返回值 0.0 ~ 1.0 之间的一个伪随机数。 实例 在本例中，我们将取得介于 0 到 1 之间的一个随机数： 12345&lt;script type=&quot;text/javascript&quot;&gt;document.write(Math.random());&lt;/script&gt;// 输出：0.15246391076246546 关于如何生成指定范围值的随机数？ 利用 parseInt()、Math.floor() 或者 Math.ceil()进行四舍五入处理 我们看到，直接使用Math.random()方法，生成的是一个小于1的数，所以： Math.random()*5 得到的结果是一个小于5的随机数。而我们通常希望得到的是0-5之间的整数，所以我们需要对得到的结果四舍五入处理一下，从而得到我们期望的整数。parseInt()、Math.floor()和Math.ceil()都可以起到四舍五入的作用。12345var randomNum = Math.random()*5;alert(randomNum); // 2.9045290905811183 alert(parseInt(randomNum,10)); // 2alert(Math.floor(randomNum)); // 2alert(Math.ceil(randomNum)); // 3 由测试的代码我们可以看到，parseInt()和Math.floor()的效果是一样的，都是向下取整数部分。所以parseInt(Math.random()*5,10)和Math.floor(Math.random()*5)都是生成的0-4之间的随机数，Math.ceil(Math.random()*5)则是生成的1-5之间的随机数。 生成指定范围数值随机数 如果你希望生成1到任意值的随机数，公式就是这样的： 1234// max - 期望的最大值parseInt(Math.random()*max,10)+1;Math.floor(Math.random()*max)+1;Math.ceil(Math.random()*max); 如果你希望生成0到任意值的随机数，公式就是这样的： 123// max - 期望的最大值parseInt(Math.random()*(max+1),10);Math.floor(Math.random()*(max+1)); 如果你希望生成任意值到任意值的随机数，公式就是这样的： 1234// max - 期望的最大值// min - 期望的最小值 parseInt(Math.random()*(max-min+1)+min,10);Math.floor(Math.random()*(max-min+1)+min);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Node.js部署到阿里云服务器","slug":"nodejs部署到阿里云全过程","date":"2017-03-16T07:26:51.000Z","updated":"2017-03-22T06:24:52.000Z","comments":true,"path":"2017/03/16/nodejs部署到阿里云全过程/","link":"","permalink":"http://yoursite.com/2017/03/16/nodejs部署到阿里云全过程/","excerpt":"","text":"整个部署过程学到了不少东西，记录一下。 参考了以下文章： http://itbilu.com/other/relate/NJ2TJohl.htmlhttps://segmentfault.com/a/1190000004051670http://borninsummer.com/2015/06/17/notes-on-developing-nodejs-webapp/https://bbs.aliyun.com/read/146189.html 1. 到阿里云购买云服务器 ECS 。https://www.aliyun.com/product/ecs如果是在校学生，在淘宝有实名认证，且在学信网有注册，可以试试抢学生的首月优惠套餐。https://www.aliyun.com/act/aliyun/campus.html作为一个穷逼+不熟悉服务器配置的菜鸟。选了最便宜的套餐：CPU： 1核 / 内存： 1024 MB / 带宽：1Mbps / 操作系统： CentOS 7.0购买环节会设置 ssh 登陆密码，记下密码。登陆到阿里云，查看购买的实例。注意公网 IP，下一步会用到2. 登陆服务器sudo ssh 你的服务器ip地址 关于 ssh 登陆，具体可以看http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html 这篇文章。 提示输入mac的密码，提示输入服务器密码。输入后连接成功并显示服务器信息，如下： 登陆服务器后。这里对于我这个 Linux 菜鸟有个大坑………就是 Linux 系统常见的目录结构和文件放置区域。使用 root 用户身份登陆后，会直接进入到下图 红色箭头标出的 root 目录下。先 cd .. 跳转到上一层, 再 ls -a ，就可以看到类似下图的目录结构了。 3.安装 node 和 mongodb node – 编译后二进制文件应在/usr/local/bin/node 下 mongodb –安装在/usr/local/mongodb 下 下面就一步一步来，首先升级CentOS 1yum -y update 升级后，跳转到 /usr/local/src , 这个文件夹通常用来存放软件源代码 1cd /usr/local/src 下载 nodejs 代码，也可以使用scp命令直接上传，因为下载实在太慢了。 12wget http://nodejs.org/dist/v0.12.5/node-v0.12.5.tar.gz//注*根据最新版本号为准 解压 1tar -xzvf node-v0.12.5.tar.gz 进入解压后的文件夹 1cd node-v0.12.5 执行配置脚本来进行编译预处理 1./configure 编译源代码 12make//注*这个时间可能会很久 当编译完成后，需要使之在系统范围内可用, 编译后的二进制文件将被放置到系统路径，默认情况下，Node二进制文件应该放在/user/local/bin/node文件夹下 1make install 安装 express 和 forever，这两个模块都推荐 global 安装 1npm -g install express forever 建立超级链接, 不然 sudo node 时会报 “command not found” 12345sudo ln -s /usr/local/bin/node /usr/bin/nodesudo ln -s /usr/local/lib/node /usr/lib/nodesudo ln -s /usr/local/bin/npm /usr/bin/npmsudo ln -s /usr/local/bin/node-waf /usr/bin/node-wafsudo ln -s /usr/local/bin/forever /usr/bin/forever Nodejs到这里就基本安装完成了。 下面来安装mongodb 软件安装位置：/usr/local/mongodb数据存放位置：/var/mongodb/data日志存放位置：/var/mongodb/logs 首先下载安装包 12cd /usr/localwget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.4.9.tgz 解压安装包，重命名文件夹为mongodb 12tar zxvf mongodb-linux-x86_64-2.6.0.tgzmv mongodb-linux-x86_64-2.6.0 mongodb 创建数据和日志存放目录 123mkdir /var/mongodbmkdir /var/mongodb/datamkdir /var/mongodb/logs 打开rc.local文件，添加CentOS开机启动项： 1vim /etc/rc.d/rc.local 将mongodb启动命令追加到本文件中，让mongodb开机自启动： 12/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork 关闭 vim 后，直接手动启动mongodb 12/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork 看到类似的信息，说明已启动成功。我在这里发了个傻，以为26308是port号，导致后面设置port时折腾了好久。其实这里的 forked process 和 port 号是两个东西， 这个是程序本身在Server上的进程。 1forked process: 26308 启动mongo shell 12cd /usr/local/mongodb/bin/./mongo 在 mongo shell 中创建管理员及数据库 12345678910111213use admin //admin 数据库db.createUser(&#123;user: &quot;用户名&quot;,pwd:&quot;登陆密码&quot;,roles:[&quot;userAdminAnyDatabase&quot;] //超级管理员&#125;)use databaseFoo //nodeapp 要连接的数据库db.createUser(&#123;user: &quot;用户名&quot;,pwd:&quot;登陆密码&quot;,roles:[&quot;readWrite&quot;] //读写权限&#125;) 到这里 mongodb 基本已经安装设置完成了。具体数据的迁移导入可自行研究。 4.配置及启动node app 我们把 nodeapp 的程序放在 /home 下 1cd /home 我使用 http://git.oschina.net/ 管理代码。它的私有库是免费的。基本操作和 github 一样。复制代码： 1git clone https://git.oschina.net/xxxxxxx/nodeapp.git //你的repo地址 注*同时可以使用图形化程序进行上传如File Zilla进入 nodeapp 文件夹 1cd nodeapp （若后续代码变更，提交到 git repo 后直接git pull即可部署代码）安装nodeapp的所有依赖 1npm install 在启动文件 ( 我的是 app.js ) 中设置数据库连接 1vim app.js 数据库连接类似下面的格式，由于数据库安装在同一服务器，因此 host 为127.0.0.1： 12var dbUrl = &apos;mongodb://用户名:登陆密码@127.0.0.1/databaseFoo&apos;;mongoose.connect(dbUrl) 这里要注意，如果直接 npm start 或 node app.js 启动，则一旦退出 ssh 远程登陆，nodeapp 就会停止运行。因此我们使用 forever 启动 nodeapp。 1NODE_ENV=production forever start app.js 如今可以使用PM2启动程序，步骤如下：使用它要先安装它，用root账号和全局模式安装一下：npm install -g pm2用它来启动程序（在当前目录下可以直接启动）pm2 start app.js --name uops 在蹚过无数坑后，项目部署成功。用浏览器打开 公网IP:端口号 即可看到 nodeapp 的首页","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-28T03:15:50.000Z","updated":"2017-03-29T02:06:59.000Z","comments":true,"path":"2017/01/28/hello-world/","link":"","permalink":"http://yoursite.com/2017/01/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://yoursite.com/tags/HelloWorld/"}]}]}