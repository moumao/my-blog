{"meta":{"title":"某猫のBlog","subtitle":null,"description":null,"author":"moumao","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-03-20T14:58:10.000Z","updated":"2017-03-20T14:58:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"你可以叫我某猫","date":"2017-03-20T12:57:33.000Z","updated":"2017-03-22T16:24:34.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"腹有诗书气自华 算是我很喜欢的一句话了吧 总是理想成为这样的人 关于我 在主站的about me中都有说过 喜欢前端，喜欢摄影，喜欢晒妻 喜欢所有美貌的一切 大抵是个颜控吧哈哈 所以也算半个果粉吧 也是别人嘴里的肥宅？？？ 今年一定要减肥 hexo的博客主题暂时用Material吧 在此谢谢vio喵的作品 关于为什么用github搭hexo 因为我的服务器装Nginx的时候炸了 就懒得再弄 其实对服务器的东西也不是很懂 打算写完自己的主题再放到服务器上 自己的主题还在开发中 主站是用node搭建的 不过很简单 也不知道写些什么上去 晒妻的照片先放到LOFTER上 之后会再做个相册的 就这些吧。 希望今年能在杭州找个说得过去的工作 感觉越学坑越多"}],"posts":[{"title":"JS中的回调函数","slug":"JS中的回调函数","date":"2017-03-24T00:28:52.000Z","updated":"2017-03-24T01:14:46.000Z","comments":true,"path":"2017/03/24/JS中的回调函数/","link":"","permalink":"http://yoursite.com/2017/03/24/JS中的回调函数/","excerpt":"","text":"###关于回调函数 首先要了解，在 js 中，函数也是对象，可以赋值给变量，可以作为参数放在函数的参数列表中。比如： 1234var doSomething = function(a,b)&#123;return a + b;&#125; 这段代码的意思是定义一个匿名函数，这个匿名函数除了没有名字之外，其他跟普通的函数没有什么两样。然后把匿名函数赋值给变量doSomething。接下来我们调用： 1console.log(doSomething(2,3));//5 回调函数，就是放在另外一个函数（如 parent）的参数列表中，作为参数传递给这个 parent，然后在 parent 函数体的某个位置执行: 123456789101112var doit = function(callback)&#123;var a = 1,b = 2,c = 3;var t = callback(a,b,c);return t + 10;&#125;;var d = doit(function(x,y,z)&#123;return (x+y+z);&#125;);console.log(d); 先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。 下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。 上述代码的执行过程是： 调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。 传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入点和一个输出点。这比较容易理解，函数本质上就是输入和输出之间实现过程的映射。 但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用，甚至在这里强烈推荐使用。 因此，回调本质上是一种设计模式，并且jQuery(包括其他框架)的设计原则遵循了这个模式。 在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。 1234567891011//基本方式function doSomething(callback) &#123;// … // Call the callbackcallback(&apos;stuff&apos;, &apos;goes&apos;, &apos;here&apos;);&#125; function foo(a, b, c) &#123;// I&apos;m the callbackalert(a + &quot; &quot; + b + &quot; &quot; + c);&#125; doSomething(foo); 123456789//匿名函数的形式function dosomething(damsg, callback)&#123;alert(damsg);if(typeof callback == &quot;function&quot;) callback();&#125; dosomething(&quot;回调函数&quot;, function()&#123;alert(&quot;和 jQuery 的 callbacks 形式一样!&quot;);&#125;); 所以callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。 回调什么时候执行 回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。 回调函数的使用场合 资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。 DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。 setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现 链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：他们的调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。 回调函数的传递 12345$.get(&apos;myhtmlpage.html&apos;, myCallBack);//这是对的$.get(&apos;myhtmlpage.html&apos;, myCallBack(&apos;foo&apos;, &apos;bar&apos;));//这是错的，那么要带参数呢？$.get(&apos;myhtmlpage.html&apos;, function()&#123;//带参数的使用函数表达式myCallBack(&apos;foo&apos;, &apos;bar&apos;);&#125;); 另外，最好保证回调存在且必须是函数引用或者函数表达式： (callback &amp;&amp; typeof(callback) ===“function”) &amp;&amp; callback(); ###回调函数使用实例 123456789101112131415//使用call方法function Thing(name) &#123;this.name = name;&#125;Thing.prototype.doSomething = function(callback) &#123;// Call our callback, but using our own instance as the contextcallback.call(this);&#125;function foo() &#123;alert(this.name);&#125;var t = new Thing(&apos;Joe&apos;);t.doSomething(foo); // Alerts &quot;Joe&quot; via `foo` 12345678910111213//传参数function Thing(name) &#123;this.name = name;&#125;Thing.prototype.doSomething = function(callback, salutation) &#123;// Call our callback, but using our own instance as the contextcallback.call(this, salutation);&#125; function foo(salutation) &#123;alert(salutation + &quot; &quot; + this.name);&#125; var t = new Thing(&apos;Joe&apos;);t.doSomething(foo, &apos;Hi&apos;); // Alerts &quot;Hi Joe&quot; via `foo` 12345678910111213//使用apply传参function Thing(name) &#123;this.name = name;&#125;Thing.prototype.doSomething = function(callback) &#123;// Call our callback, but using our own instance as the contextcallback.apply(this, [&apos;Hi&apos;, 3, 2, 1]);&#125; function foo(salutation, three, two, one) &#123;alert(salutation + &quot; &quot; + this.name + &quot; – &quot; + three + &quot; &quot; + two + &quot; &quot; + one);&#125; var t = new Thing(&apos;Joe&apos;);t.doSomething(foo); // Alerts &quot;Hi Joe – 3 2 1&quot; via `foo` 1234567891011121314//假如提供的数据源是一整数,为某学生的分数,当num&lt;=0,由底层处理,当n&gt;0时由高层处理.//将下面这个函数拷贝下来存盘为1.jsfunction f(num,callback)&#123;if(num&lt;0) &#123; alert(&quot;调用低层函数处理!&quot;);alert(&quot;分数不能为负,输入错误!&quot;); &#125;else if(num==0)&#123;alert(&quot;调用低层函数处理!&quot;);alert(&quot;该学生可能未参加考试！&quot;);&#125;else&#123;alert(&quot;调用高层函数处理!&quot;);callback();&#125;&#125; 12345678910111213141516171819202122232425262728293031//将下面这个test.html文件存盘与1.js在一个目录下：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;&lt;script src=&quot;1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;function test()&#123;var p=document.getElementById(&quot;pp&quot;);pp.innerText=&quot;&quot;;var num=document.getElementById(&quot;score&quot;).value;f(num,function()&#123; //匿名高层处理函数if(num&lt;60) alert(&quot;未及格！&quot;);else if(num&lt;=90) alert(&quot;该生成绩优良！&quot;);else alert(&quot;该生成绩优秀!&quot;); &#125;)pp.innerText=&quot;by since1978 qq558064!&quot;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;回调函数示例:当学生成绩score&lt;=0分时候，由底层处理；当score&gt;0时，由高层处理。&lt;/p&gt;请输入学生成绩&lt;input type=&quot;text&quot; id=&quot;score&quot;&gt; &lt;input type=&quot;button&quot; onClick=&quot;test()&quot; value=&quot; 看看结果&quot;&gt;&lt;p id=&quot;pp&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456//node.js中出现的回调函数app.use(function(req, res, next) &#123;var err = new Error(&apos;Not Found&apos;);err.status = 404;next(err);&#125;); ###小结回调函数是实现js异步编程的四种方法之一，但并不推荐用此方法： 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 不过正如上文所说，回调函数不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。 在javascript中回调函数非常重要，它们几乎无处不在","categories":[],"tags":[{"name":"js 回调函数","slug":"js-回调函数","permalink":"http://yoursite.com/tags/js-回调函数/"}]},{"title":"什么是动态HTML？-DHTML","slug":"什么是动态HTML？-DHTML","date":"2017-03-23T14:07:50.000Z","updated":"2017-03-24T01:14:39.000Z","comments":true,"path":"2017/03/23/什么是动态HTML？-DHTML/","link":"","permalink":"http://yoursite.com/2017/03/23/什么是动态HTML？-DHTML/","excerpt":"","text":"DHTML是Dynamic HTML的简称，中文译为“动态超文本标记语言”，主要用途是提**TML页面的交互性和可操作性。它是建立在传统HTML基础上的客户端动态技术，是一种技术的总称，它通过HTML、VBScript、JavaScript邮和CSS等语言、技术使网页能够具有动态交互功能。虽然HTML语言可以制作出具有复杂格式的网页，但这样制作出来的网页只包含静态内容。凡是网页上有任何信息需要更新，浏览器就必须从服务器上重新下载整个网页，因而给网络造成极大的负担。它是建立在传统HTML基础上的客户端动态技术。 DHTML实现了网页从Web服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。这是近年来网络飞速发展进程中员振奋人心也最具实用性的技术之一。DHTML是一种通过各种技术的综合发展而来的概念，这些技术包括JavaScript、VBScript、DOM(Document Object Mode，文档对象模型)、Layers和CSS(Cascading Style Sheets，层又叠样式表)等。目前IE4．0以上的大多数浏览器都加入了对DHTML的支持，主要包括以下内容： ①动态内容(Dynamic Content)：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。​ ②动态排版样式(Dynamic StyleSheets)：W3C的CSS样式表提供了设定HTML标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。","categories":[],"tags":[{"name":"HTML DHTML","slug":"HTML-DHTML","permalink":"http://yoursite.com/tags/HTML-DHTML/"}]},{"title":"JS中this的指向","slug":"JS中this的指向","date":"2017-03-22T06:14:42.000Z","updated":"2017-03-22T06:19:36.000Z","comments":true,"path":"2017/03/22/JS中this的指向/","link":"","permalink":"http://yoursite.com/2017/03/22/JS中this的指向/","excerpt":"","text":"this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如: 12345function test()&#123; this.x = 1; &#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 下面分四种情况，详细讨论this的用法。 情况一：纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象。 请看下面这段代码，它的运行结果是1。 123456789function test()&#123; this.x = 1; alert(this.x); &#125; test(); // 1 为了证明this就是全局对象，我对代码做一些改变： 123456789var x = 1; function test()&#123; alert(this.x); &#125; test(); // 1 运行结果还是1。再变一下： 1234567891011var x = 1; function test()&#123; this.x = 0; &#125; test(); alert(x); //0 情况二：作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象。 12345678910111213function test()&#123; alert(this.x); &#125; var o = &#123;&#125;; o.x = 1; o.m = test; o.m(); // 1 情况三 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 123456789function test()&#123; this.x = 1; &#125; var o = new test(); alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变： 1234567891011var x = 2; function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 情况四 apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数 123456789101112131415var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。 如果把最后一行代码修改为 : 1o.m.apply(o); //1 运行结果就变成了1，证明了这时this代表的是对象o","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":" js中Math.random()生成指定范围数值的随机数","slug":"js中Math-random-生成指定范围数值的随机数","date":"2017-03-20T15:43:56.000Z","updated":"2017-03-22T06:24:58.000Z","comments":true,"path":"2017/03/20/js中Math-random-生成指定范围数值的随机数/","link":"","permalink":"http://yoursite.com/2017/03/20/js中Math-random-生成指定范围数值的随机数/","excerpt":"","text":"定义和用法 random() 方法可返回介于 0 ~ 1 之间的一个随机数。 语法 Math.random() 返回值 0.0 ~ 1.0 之间的一个伪随机数。 实例 在本例中，我们将取得介于 0 到 1 之间的一个随机数： 12345&lt;script type=&quot;text/javascript&quot;&gt;document.write(Math.random());&lt;/script&gt;// 输出：0.15246391076246546 关于如何生成指定范围值的随机数？ 利用 parseInt()、Math.floor() 或者 Math.ceil()进行四舍五入处理 我们看到，直接使用Math.random()方法，生成的是一个小于1的数，所以： Math.random()*5 得到的结果是一个小于5的随机数。而我们通常希望得到的是0-5之间的整数，所以我们需要对得到的结果四舍五入处理一下，从而得到我们期望的整数。parseInt()、Math.floor()和Math.ceil()都可以起到四舍五入的作用。12345var randomNum = Math.random()*5;alert(randomNum); // 2.9045290905811183 alert(parseInt(randomNum,10)); // 2alert(Math.floor(randomNum)); // 2alert(Math.ceil(randomNum)); // 3 由测试的代码我们可以看到，parseInt()和Math.floor()的效果是一样的，都是向下取整数部分。所以parseInt(Math.random()*5,10)和Math.floor(Math.random()*5)都是生成的0-4之间的随机数，Math.ceil(Math.random()*5)则是生成的1-5之间的随机数。 生成指定范围数值随机数 如果你希望生成1到任意值的随机数，公式就是这样的： 1234// max - 期望的最大值parseInt(Math.random()*max,10)+1;Math.floor(Math.random()*max)+1;Math.ceil(Math.random()*max); 如果你希望生成0到任意值的随机数，公式就是这样的： 123// max - 期望的最大值parseInt(Math.random()*(max+1),10);Math.floor(Math.random()*(max+1)); 如果你希望生成任意值到任意值的随机数，公式就是这样的： 1234// max - 期望的最大值// min - 期望的最小值 parseInt(Math.random()*(max-min+1)+min,10);Math.floor(Math.random()*(max-min+1)+min);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Node.js部署到阿里云服务器","slug":"nodejs部署到阿里云全过程","date":"2017-03-16T07:26:51.000Z","updated":"2017-03-22T06:24:52.000Z","comments":true,"path":"2017/03/16/nodejs部署到阿里云全过程/","link":"","permalink":"http://yoursite.com/2017/03/16/nodejs部署到阿里云全过程/","excerpt":"","text":"整个部署过程学到了不少东西，记录一下。 参考了以下文章： http://itbilu.com/other/relate/NJ2TJohl.htmlhttps://segmentfault.com/a/1190000004051670http://borninsummer.com/2015/06/17/notes-on-developing-nodejs-webapp/https://bbs.aliyun.com/read/146189.html 1. 到阿里云购买云服务器 ECS 。https://www.aliyun.com/product/ecs如果是在校学生，在淘宝有实名认证，且在学信网有注册，可以试试抢学生的首月优惠套餐。https://www.aliyun.com/act/aliyun/campus.html作为一个穷逼+不熟悉服务器配置的菜鸟。选了最便宜的套餐：CPU： 1核 / 内存： 1024 MB / 带宽：1Mbps / 操作系统： CentOS 7.0购买环节会设置 ssh 登陆密码，记下密码。登陆到阿里云，查看购买的实例。注意公网 IP，下一步会用到2. 登陆服务器sudo ssh 你的服务器ip地址 关于 ssh 登陆，具体可以看http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html 这篇文章。 提示输入mac的密码，提示输入服务器密码。输入后连接成功并显示服务器信息，如下： 登陆服务器后。这里对于我这个 Linux 菜鸟有个大坑………就是 Linux 系统常见的目录结构和文件放置区域。使用 root 用户身份登陆后，会直接进入到下图 红色箭头标出的 root 目录下。先 cd .. 跳转到上一层, 再 ls -a ，就可以看到类似下图的目录结构了。 3.安装 node 和 mongodb node – 编译后二进制文件应在/usr/local/bin/node 下 mongodb –安装在/usr/local/mongodb 下 下面就一步一步来，首先升级CentOS 1yum -y update 升级后，跳转到 /usr/local/src , 这个文件夹通常用来存放软件源代码 1cd /usr/local/src 下载 nodejs 代码，也可以使用scp命令直接上传，因为下载实在太慢了。 12wget http://nodejs.org/dist/v0.12.5/node-v0.12.5.tar.gz//注*根据最新版本号为准 解压 1tar -xzvf node-v0.12.5.tar.gz 进入解压后的文件夹 1cd node-v0.12.5 执行配置脚本来进行编译预处理 1./configure 编译源代码 12make//注*这个时间可能会很久 当编译完成后，需要使之在系统范围内可用, 编译后的二进制文件将被放置到系统路径，默认情况下，Node二进制文件应该放在/user/local/bin/node文件夹下 1make install 安装 express 和 forever，这两个模块都推荐 global 安装 1npm -g install express forever 建立超级链接, 不然 sudo node 时会报 “command not found” 12345sudo ln -s /usr/local/bin/node /usr/bin/nodesudo ln -s /usr/local/lib/node /usr/lib/nodesudo ln -s /usr/local/bin/npm /usr/bin/npmsudo ln -s /usr/local/bin/node-waf /usr/bin/node-wafsudo ln -s /usr/local/bin/forever /usr/bin/forever Nodejs到这里就基本安装完成了。 下面来安装mongodb 软件安装位置：/usr/local/mongodb数据存放位置：/var/mongodb/data日志存放位置：/var/mongodb/logs 首先下载安装包 12cd /usr/localwget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.4.9.tgz 解压安装包，重命名文件夹为mongodb 12tar zxvf mongodb-linux-x86_64-2.6.0.tgzmv mongodb-linux-x86_64-2.6.0 mongodb 创建数据和日志存放目录 123mkdir /var/mongodbmkdir /var/mongodb/datamkdir /var/mongodb/logs 打开rc.local文件，添加CentOS开机启动项： 1vim /etc/rc.d/rc.local 将mongodb启动命令追加到本文件中，让mongodb开机自启动： 12/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork 关闭 vim 后，直接手动启动mongodb 12/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork 看到类似的信息，说明已启动成功。我在这里发了个傻，以为26308是port号，导致后面设置port时折腾了好久。其实这里的 forked process 和 port 号是两个东西， 这个是程序本身在Server上的进程。 1forked process: 26308 启动mongo shell 12cd /usr/local/mongodb/bin/./mongo 在 mongo shell 中创建管理员及数据库 12345678910111213use admin //admin 数据库db.createUser(&#123;user: &quot;用户名&quot;,pwd:&quot;登陆密码&quot;,roles:[&quot;userAdminAnyDatabase&quot;] //超级管理员&#125;)use databaseFoo //nodeapp 要连接的数据库db.createUser(&#123;user: &quot;用户名&quot;,pwd:&quot;登陆密码&quot;,roles:[&quot;readWrite&quot;] //读写权限&#125;) 到这里 mongodb 基本已经安装设置完成了。具体数据的迁移导入可自行研究。 4.配置及启动node app 我们把 nodeapp 的程序放在 /home 下 1cd /home 我使用 http://git.oschina.net/ 管理代码。它的私有库是免费的。基本操作和 github 一样。复制代码： 1git clone https://git.oschina.net/xxxxxxx/nodeapp.git //你的repo地址 注*同时可以使用图形化程序进行上传如File Zilla进入 nodeapp 文件夹 1cd nodeapp （若后续代码变更，提交到 git repo 后直接git pull即可部署代码）安装nodeapp的所有依赖 1npm install 在启动文件 ( 我的是 app.js ) 中设置数据库连接 1vim app.js 数据库连接类似下面的格式，由于数据库安装在同一服务器，因此 host 为127.0.0.1： 12var dbUrl = &apos;mongodb://用户名:登陆密码@127.0.0.1/databaseFoo&apos;;mongoose.connect(dbUrl) 这里要注意，如果直接 npm start 或 node app.js 启动，则一旦退出 ssh 远程登陆，nodeapp 就会停止运行。因此我们使用 forever 启动 nodeapp。 1NODE_ENV=production forever start app.js 如今可以使用PM2启动程序，步骤如下：使用它要先安装它，用root账号和全局模式安装一下：npm install -g pm2用它来启动程序（在当前目录下可以直接启动）pm2 start app.js --name uops 在蹚过无数坑后，项目部署成功。用浏览器打开 公网IP:端口号 即可看到 nodeapp 的首页","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-16T02:04:34.000Z","updated":"2017-03-20T15:00:11.000Z","comments":true,"path":"2017/03/16/hello-world/","link":"","permalink":"http://yoursite.com/2017/03/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://yoursite.com/tags/HelloWorld/"}]}]}